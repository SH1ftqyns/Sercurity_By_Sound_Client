Index: app/src/main/java/com/duowan/mobile/netroid/NetworkError.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/NetworkError.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/NetworkError.java	(revision )
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+/**
+ * Indicates that there was a network error when performing a Netroid request.
+ */
+@SuppressWarnings("serial")
+public class NetworkError extends NetroidError {
+    public NetworkError() {
+        super();
+    }
+
+    public NetworkError(Throwable cause) {
+        super(cause);
+    }
+
+    public NetworkError(NetworkResponse networkResponse) {
+        super(networkResponse);
+    }
+}
Index: app/src/main/java/com/duowan/mobile/netroid/image/NetworkImageView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/image/NetworkImageView.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/image/NetworkImageView.java	(revision )
@@ -0,0 +1,214 @@
+/**
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.duowan.mobile.netroid.image;
+
+import android.content.Context;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.ImageView;
+import com.duowan.mobile.netroid.NetroidError;
+import com.duowan.mobile.netroid.toolbox.ImageLoader;
+import com.duowan.mobile.netroid.toolbox.ImageLoader.ImageContainer;
+import com.duowan.mobile.netroid.toolbox.ImageLoader.ImageListener;
+
+/**
+ * Handles fetching an image from a URL as well as the life-cycle of the
+ * associated request.
+ */
+public class NetworkImageView extends ImageView {
+    /** The URL of the network image to load */
+    private String mUrl;
+
+    /**
+     * Resource ID of the image to be used as a placeholder until the network image is loaded.
+     */
+    private int mDefaultImageId;
+
+    /**
+     * Resource ID of the image to be used if the network response fails.
+     */
+    private int mErrorImageId;
+
+    /** Local copy of the ImageLoader. */
+    private ImageLoader mImageLoader;
+
+    /** Current ImageContainer. (either in-flight or finished) */
+    private ImageContainer mImageContainer;
+
+    public NetworkImageView(Context context) {
+        this(context, null);
+    }
+
+    public NetworkImageView(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public NetworkImageView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+    }
+
+    /**
+     * Sets URL of the image that should be loaded into this view. Note that calling this will
+     * immediately either set the cached image (if available) or the default image specified by
+     * {@link NetworkImageView#setDefaultImageResId(int)} on the view.
+     *
+     * NOTE: If applicable, {@link NetworkImageView#setDefaultImageResId(int)} and
+     * {@link NetworkImageView#setErrorImageResId(int)} should be called prior to calling
+     * this function.
+     *
+     * @param url The URL that should be loaded into this ImageView.
+     * @param imageLoader ImageLoader that will be used to make the request.
+     */
+    public void setImageUrl(String url, ImageLoader imageLoader) {
+        mUrl = url;
+        mImageLoader = imageLoader;
+        // The URL has potentially changed. See if we need to load it.
+        loadImageIfNecessary(false);
+    }
+
+    /**
+     * Sets the default image resource ID to be used for this view until the attempt to load it
+     * completes.
+     */
+    public void setDefaultImageResId(int defaultImage) {
+        mDefaultImageId = defaultImage;
+    }
+
+    /**
+     * Sets the error image resource ID to be used for this view in the event that the image
+     * requested fails to load.
+     */
+    public void setErrorImageResId(int errorImage) {
+        mErrorImageId = errorImage;
+    }
+
+    /**
+     * Loads the image for the view if it isn't already loaded.
+     * @param isInLayoutPass True if this was invoked from a layout pass, false otherwise.
+     */
+    private void loadImageIfNecessary(final boolean isInLayoutPass) {
+        int width = getWidth();
+        int height = getHeight();
+
+        boolean wrapWidth = false, wrapHeight = false;
+        if (getLayoutParams() != null) {
+            wrapWidth = getLayoutParams().width == LayoutParams.WRAP_CONTENT;
+            wrapHeight = getLayoutParams().height == LayoutParams.WRAP_CONTENT;
+        }
+
+        // if the view's bounds aren't known yet, and this is not a wrap-content/wrap-content
+        // view, hold off on loading the image.
+        boolean isFullyWrapContent = wrapWidth && wrapHeight;
+        if (width == 0 && height == 0 && !isFullyWrapContent) {
+            return;
+        }
+
+        // if the URL to be loaded in this view is empty, cancel any old requests and clear the
+        // currently loaded image.
+        if (TextUtils.isEmpty(mUrl)) {
+            if (mImageContainer != null) {
+                mImageContainer.cancelRequest();
+                mImageContainer = null;
+            }
+            setDefaultImageOrNull();
+            return;
+        }
+
+        // if there was an old request in this view, check if it needs to be canceled.
+        if (mImageContainer != null && mImageContainer.getRequestUrl() != null) {
+            if (mImageContainer.getRequestUrl().equals(mUrl)) {
+                // if the request is from the same URL, return.
+                return;
+            } else {
+                // if there is a pre-existing request, cancel it if it's fetching a different URL.
+                mImageContainer.cancelRequest();
+            }
+        }
+
+		// Calculate the max image width / height to use while ignoring WRAP_CONTENT dimens.
+		int maxWidth = wrapWidth ? 0 : width;
+		int maxHeight = wrapHeight ? 0 : height;
+
+        // The pre-existing content of this view didn't match the current URL.
+        // Load the new image from the network.
+		mImageContainer = mImageLoader.get(mUrl,
+                new ImageListener() {
+                    @Override
+                    public void onError(NetroidError error) {
+                        if (mErrorImageId != 0) {
+                            setImageResource(mErrorImageId);
+                        }
+                    }
+
+                    @Override
+                    public void onSuccess(final ImageContainer response, boolean isImmediate) {
+                        // If this was an immediate response that was delivered inside of a layout
+                        // pass do not set the image immediately as it will trigger a requestLayout
+                        // inside of a layout. Instead, defer setting the image by posting back to
+                        // the main thread.
+                        if (isImmediate && isInLayoutPass) {
+                            post(new Runnable() {
+								@Override
+								public void run() {
+									onSuccess(response, false);
+								}
+							});
+							return;
+						}
+
+						if (response.getBitmap() != null) {
+							setImageBitmap(response.getBitmap());
+						} else {
+							setDefaultImageOrNull();
+                        }
+                    }
+                }, maxWidth, maxHeight);
+    }
+
+    private void setDefaultImageOrNull() {
+		if (mDefaultImageId != 0) {
+			setImageResource(mDefaultImageId);
+		} else {
+			setImageBitmap(null);
+		}
+	}
+
+    @Override
+    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+        super.onLayout(changed, left, top, right, bottom);
+        loadImageIfNecessary(true);
+    }
+
+    @Override
+    protected void onDetachedFromWindow() {
+        if (mImageContainer != null) {
+            // If the view was bound to an image request, cancel it and clear
+            // out the image from the view.
+            mImageContainer.cancelRequest();
+            setImageBitmap(null);
+            // also clear out the container so we can reload the image if necessary.
+            mImageContainer = null;
+        }
+        super.onDetachedFromWindow();
+    }
+
+    @Override
+    protected void drawableStateChanged() {
+        super.drawableStateChanged();
+        invalidate();
+    }
+}
Index: app/src/main/java/com/duowan/mobile/netroid/ServerError.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/ServerError.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/ServerError.java	(revision )
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+/**
+ * Indicates that the error responded with an error response.
+ */
+@SuppressWarnings("serial")
+public class ServerError extends NetroidError {
+    public ServerError(NetworkResponse networkResponse) {
+        super(networkResponse);
+    }
+
+    public ServerError() {
+        super();
+    }
+}
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/AndroidManifest.xml	(revision )
+++ app/src/main/AndroidManifest.xml	(revision )
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.example.bl_uestc.sercurity_bysound">
+
+    <application
+        android:allowBackup="true"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:supportsRtl="true"
+        android:theme="@style/AppTheme">
+        <activity
+            android:name=".MainActivity"
+            android:label="@string/app_name"
+            android:theme="@style/AppTheme">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+
+
+    </application>
+
+    <uses-permission android:name="android.permission.INTERNET"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
+</manifest>
Index: app/src/main/java/com/duowan/mobile/example/netroid/netroid/PostByParamsRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/example/netroid/netroid/PostByParamsRequest.java	(revision )
+++ app/src/main/java/com/duowan/mobile/example/netroid/netroid/PostByParamsRequest.java	(revision )
@@ -0,0 +1,19 @@
+package com.duowan.mobile.example.netroid.netroid;
+
+import java.util.Map;
+
+import com.duowan.mobile.netroid.AuthFailureError;
+import com.duowan.mobile.netroid.Listener;
+import com.duowan.mobile.netroid.request.StringRequest;
+
+public class PostByParamsRequest  extends StringRequest{
+	private Map<String, String> mParams;
+	public PostByParamsRequest(String url, Map<String, String> params,Listener<String> listener) {
+		super(Method.POST,url,listener);
+		mParams=params;
+		// TODO Auto-generated constructor stub
+	}
+	public Map<String, String> getParams() throws AuthFailureError {
+        return mParams;
+    }
+}
Index: app/src/main/res/values-v21/styles.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values-v21/styles.xml	(revision )
+++ app/src/main/res/values-v21/styles.xml	(revision )
@@ -0,0 +1,9 @@
+<resources>>
+
+    <style name="AppTheme.NoActionBar">
+        <item name="windowActionBar">false</item>
+        <item name="windowNoTitle">true</item>
+        <item name="android:windowDrawsSystemBarBackgrounds">true</item>
+        <item name="android:statusBarColor">@android:color/transparent</item>
+    </style>
+</resources>
Index: app/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/.gitignore	(revision )
+++ app/.gitignore	(revision )
@@ -0,0 +1,1 @@
+/build
Index: app/src/main/java/com/duowan/mobile/netroid/request/JsonArrayRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/request/JsonArrayRequest.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/request/JsonArrayRequest.java	(revision )
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.request;
+
+import com.duowan.mobile.netroid.Listener;
+import com.duowan.mobile.netroid.NetworkResponse;
+import com.duowan.mobile.netroid.ParseError;
+import com.duowan.mobile.netroid.Response;
+import org.json.JSONArray;
+import org.json.JSONException;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * A request for retrieving a {@link JSONArray} response body at a given URL.
+ */
+public class JsonArrayRequest extends JsonRequest<JSONArray> {
+    /**
+     * Creates a new request.
+     * @param url URL to fetch the JSON from
+     * @param listener Listener to receive the JSON response or error message
+     */
+    public JsonArrayRequest(String url, Listener<JSONArray> listener) {
+        super(Method.GET, url, null, listener);
+    }
+
+    @Override
+    protected Response<JSONArray> parseNetworkResponse(NetworkResponse response) {
+        try {
+            String jsonString = new String(response.data, response.charset);
+            return Response.success(new JSONArray(jsonString), response);
+        } catch (UnsupportedEncodingException e) {
+            return Response.error(new ParseError(e));
+        } catch (JSONException je) {
+            return Response.error(new ParseError(je));
+        }
+    }
+}
Index: settings.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- settings.gradle	(revision )
+++ settings.gradle	(revision )
@@ -0,0 +1,1 @@
+include ':app'
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .gitignore	(revision )
+++ .gitignore	(revision )
@@ -0,0 +1,8 @@
+*.iml
+.gradle
+/local.properties
+/.idea/workspace.xml
+/.idea/libraries
+.DS_Store
+/build
+/captures
Index: gradlew
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- gradlew	(revision )
+++ gradlew	(revision )
@@ -0,0 +1,160 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+    JAVACMD=`cygpath --unix "$JAVACMD"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
Index: app/src/main/java/com/duowan/mobile/netroid/NoConnectionError.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/NoConnectionError.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/NoConnectionError.java	(revision )
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+/**
+ * Error indicating that no connection could be established when performing a Netroid request.
+ */
+@SuppressWarnings("serial")
+public class NoConnectionError extends NetworkError {
+    public NoConnectionError() {
+        super();
+    }
+
+    public NoConnectionError(Throwable reason) {
+        super(reason);
+    }
+}
Index: app/src/main/java/com/duowan/mobile/netroid/cache/LruCache.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/cache/LruCache.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/cache/LruCache.java	(revision )
@@ -0,0 +1,323 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.duowan.mobile.netroid.cache;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+/**
+ * This class copy from android support v4.
+ * Static library version of {@link android.util.LruCache}. Used to write apps
+ * that run on API levels prior to 12. When running on API level 12 or above,
+ * this implementation is still used; it does not try to switch to the
+ * framework's implementation. See the framework SDK documentation for a class
+ * overview.
+ */
+public class LruCache<K, V> {
+	private final LinkedHashMap<K, V> map;
+
+	/** Size of this cache in units. Not necessarily the number of elements. */
+	private int size;
+	private int maxSize;
+
+	private int putCount;
+	private int createCount;
+	private int evictionCount;
+	private int hitCount;
+	private int missCount;
+
+	/**
+	 * @param maxSize for caches that do not override {@link #sizeOf}, this is
+	 *     the maximum number of entries in the cache. For all other caches,
+	 *     this is the maximum sum of the sizes of the entries in this cache.
+	 */
+	public LruCache(int maxSize) {
+		if (maxSize <= 0) {
+			throw new IllegalArgumentException("maxSize <= 0");
+		}
+		this.maxSize = maxSize;
+		this.map = new LinkedHashMap<K, V>(0, 0.75f, true);
+	}
+
+	/**
+	 * Returns the value for {@code key} if it exists in the cache or can be
+	 * created by {@code #create}. If a value was returned, it is moved to the
+	 * head of the queue. This returns null if a value is not cached and cannot
+	 * be created.
+	 */
+	public final V get(K key) {
+		if (key == null) {
+			throw new NullPointerException("key == null");
+		}
+
+		V mapValue;
+		synchronized (this) {
+			mapValue = map.get(key);
+			if (mapValue != null) {
+				hitCount++;
+				return mapValue;
+			}
+			missCount++;
+		}
+
+        /*
+         * Attempt to create a value. This may take a long time, and the map
+         * may be different when create() returns. If a conflicting value was
+         * added to the map while create() was working, we leave that value in
+         * the map and release the created value.
+         */
+
+		V createdValue = create(key);
+		if (createdValue == null) {
+			return null;
+		}
+
+		synchronized (this) {
+			createCount++;
+			mapValue = map.put(key, createdValue);
+
+			if (mapValue != null) {
+				// There was a conflict so undo that last put
+				map.put(key, mapValue);
+			} else {
+				size += safeSizeOf(key, createdValue);
+			}
+		}
+
+		if (mapValue != null) {
+			entryRemoved(false, key, createdValue, mapValue);
+			return mapValue;
+		} else {
+			trimToSize(maxSize);
+			return createdValue;
+		}
+	}
+
+	/**
+	 * Caches {@code value} for {@code key}. The value is moved to the head of
+	 * the queue.
+	 *
+	 * @return the previous value mapped by {@code key}.
+	 */
+	public final V put(K key, V value) {
+		if (key == null || value == null) {
+			throw new NullPointerException("key == null || value == null");
+		}
+
+		V previous;
+		synchronized (this) {
+			putCount++;
+			size += safeSizeOf(key, value);
+			previous = map.put(key, value);
+			if (previous != null) {
+				size -= safeSizeOf(key, previous);
+			}
+		}
+
+		if (previous != null) {
+			entryRemoved(false, key, previous, value);
+		}
+
+		trimToSize(maxSize);
+		return previous;
+	}
+
+	/**
+	 * @param maxSize the maximum size of the cache before returning. May be -1
+	 *     to evict even 0-sized elements.
+	 */
+	private void trimToSize(int maxSize) {
+		while (true) {
+			K key;
+			V value;
+			synchronized (this) {
+				if (size < 0 || (map.isEmpty() && size != 0)) {
+					throw new IllegalStateException(getClass().getName()
+							+ ".sizeOf() is reporting inconsistent results!");
+				}
+
+				if (size <= maxSize || map.isEmpty()) {
+					break;
+				}
+
+				Map.Entry<K, V> toEvict = map.entrySet().iterator().next();
+				key = toEvict.getKey();
+				value = toEvict.getValue();
+				map.remove(key);
+				size -= safeSizeOf(key, value);
+				evictionCount++;
+			}
+
+			entryRemoved(true, key, value, null);
+		}
+	}
+
+	/**
+	 * Removes the entry for {@code key} if it exists.
+	 *
+	 * @return the previous value mapped by {@code key}.
+	 */
+	public final V remove(K key) {
+		if (key == null) {
+			throw new NullPointerException("key == null");
+		}
+
+		V previous;
+		synchronized (this) {
+			previous = map.remove(key);
+			if (previous != null) {
+				size -= safeSizeOf(key, previous);
+			}
+		}
+
+		if (previous != null) {
+			entryRemoved(false, key, previous, null);
+		}
+
+		return previous;
+	}
+
+	/**
+	 * Called for entries that have been evicted or removed. This method is
+	 * invoked when a value is evicted to make space, removed by a call to
+	 * {@link #remove}, or replaced by a call to {@link #put}. The default
+	 * implementation does nothing.
+	 *
+	 * <p>The method is called without synchronization: other threads may
+	 * access the cache while this method is executing.
+	 *
+	 * @param evicted true if the entry is being removed to make space, false
+	 *     if the removal was caused by a {@link #put} or {@link #remove}.
+	 * @param newValue the new value for {@code key}, if it exists. If non-null,
+	 *     this removal was caused by a {@link #put}. Otherwise it was caused by
+	 *     an eviction or a {@link #remove}.
+	 */
+	protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
+
+	/**
+	 * Called after a cache miss to compute a value for the corresponding key.
+	 * Returns the computed value or null if no value can be computed. The
+	 * default implementation returns null.
+	 *
+	 * <p>The method is called without synchronization: other threads may
+	 * access the cache while this method is executing.
+	 *
+	 * <p>If a value for {@code key} exists in the cache when this method
+	 * returns, the created value will be released with {@link #entryRemoved}
+	 * and discarded. This can occur when multiple threads request the same key
+	 * at the same time (causing multiple values to be created), or when one
+	 * thread calls {@link #put} while another is creating a value for the same
+	 * key.
+	 */
+	protected V create(K key) {
+		return null;
+	}
+
+	private int safeSizeOf(K key, V value) {
+		int result = sizeOf(key, value);
+		if (result < 0) {
+			throw new IllegalStateException("Negative size: " + key + "=" + value);
+		}
+		return result;
+	}
+
+	/**
+	 * Returns the size of the entry for {@code key} and {@code value} in
+	 * user-defined units.  The default implementation returns 1 so that size
+	 * is the number of entries and max size is the maximum number of entries.
+	 *
+	 * <p>An entry's size must not change while it is in the cache.
+	 */
+	protected int sizeOf(K key, V value) {
+		return 1;
+	}
+
+	/**
+	 * Clear the cache, calling {@link #entryRemoved} on each removed entry.
+	 */
+	public final void evictAll() {
+		trimToSize(-1); // -1 will evict 0-sized elements
+	}
+
+	/**
+	 * For caches that do not override {@link #sizeOf}, this returns the number
+	 * of entries in the cache. For all other caches, this returns the sum of
+	 * the sizes of the entries in this cache.
+	 */
+	public synchronized final int size() {
+		return size;
+	}
+
+	/**
+	 * For caches that do not override {@link #sizeOf}, this returns the maximum
+	 * number of entries in the cache. For all other caches, this returns the
+	 * maximum sum of the sizes of the entries in this cache.
+	 */
+	public synchronized final int maxSize() {
+		return maxSize;
+	}
+
+	/**
+	 * Returns the number of times {@link #get} returned a value.
+	 */
+	public synchronized final int hitCount() {
+		return hitCount;
+	}
+
+	/**
+	 * Returns the number of times {@link #get} returned null or required a new
+	 * value to be created.
+	 */
+	public synchronized final int missCount() {
+		return missCount;
+	}
+
+	/**
+	 * Returns the number of times {@link #create(Object)} returned a value.
+	 */
+	public synchronized final int createCount() {
+		return createCount;
+	}
+
+	/**
+	 * Returns the number of times {@link #put} was called.
+	 */
+	public synchronized final int putCount() {
+		return putCount;
+	}
+
+	/**
+	 * Returns the number of values that have been evicted.
+	 */
+	public synchronized final int evictionCount() {
+		return evictionCount;
+	}
+
+	/**
+	 * Returns a copy of the current contents of the cache, ordered from least
+	 * recently accessed to most recently accessed.
+	 */
+	public synchronized final Map<K, V> snapshot() {
+		return new LinkedHashMap<K, V>(map);
+	}
+
+	@Override public synchronized final String toString() {
+		int accesses = hitCount + missCount;
+		int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;
+		return String.format("LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]",
+				maxSize, hitCount, missCount, hitPercent);
+	}
+}
Index: app/src/main/res/values/colors.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/colors.xml	(revision )
+++ app/src/main/res/values/colors.xml	(revision )
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <color name="colorPrimary">#3F51B5</color>
+    <color name="colorPrimaryDark">#303F9F</color>
+    <color name="colorAccent">#FF4081</color>
+    <color name="background_tab_pressed">#6633B5E5</color>
+
+
+</resources>
Index: app/src/main/java/com/duowan/mobile/netroid/DefaultRetryPolicy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/DefaultRetryPolicy.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/DefaultRetryPolicy.java	(revision )
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+/**
+ * Default retry policy for requests.
+ */
+public class DefaultRetryPolicy implements RetryPolicy {
+    /** The current timeout in milliseconds. */
+    private int mCurrentTimeoutMs;
+
+    /** The current retry count. */
+    private int mCurrentRetryCount;
+
+    /** The maximum number of attempts. */
+    private final int mMaxNumRetries;
+
+    /** The backoff multiplier for for the policy. */
+    private final float mBackoffMultiplier;
+
+    /** The default socket timeout in milliseconds */
+    public static final int DEFAULT_TIMEOUT_MS = 2500;
+
+    /** The default number of retries */
+    public static final int DEFAULT_MAX_RETRIES = 1;
+
+    /** The default backoff multiplier */
+    public static final float DEFAULT_BACKOFF_MULT = 1f;
+
+    /**
+     * Constructs a new retry policy using the default timeouts.
+     */
+    public DefaultRetryPolicy() {
+        this(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);
+    }
+
+    /**
+     * Constructs a new retry policy.
+     * @param initialTimeoutMs The initial timeout for the policy.
+     * @param maxNumRetries The maximum number of retries.
+     * @param backoffMultiplier Backoff multiplier for the policy.
+     */
+    public DefaultRetryPolicy(int initialTimeoutMs, int maxNumRetries, float backoffMultiplier) {
+        mCurrentTimeoutMs = initialTimeoutMs;
+        mMaxNumRetries = maxNumRetries;
+        mBackoffMultiplier = backoffMultiplier;
+    }
+
+    /**
+     * Returns the current timeout.
+     */
+    @Override
+    public int getCurrentTimeout() {
+        return mCurrentTimeoutMs;
+    }
+
+    /**
+     * Returns the current retry count.
+     */
+    @Override
+    public int getCurrentRetryCount() {
+        return mCurrentRetryCount;
+    }
+
+    /**
+     * Prepares for the next retry by applying a backoff to the timeout.
+     * @param error The error code of the last attempt.
+     */
+    @Override
+    public void retry(NetroidError error) throws NetroidError {
+        mCurrentRetryCount++;
+        mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);
+        if (!hasAttemptRemaining()) {
+            throw error;
+        }
+    }
+
+    /**
+     * Returns true if this policy has attempts remaining, false otherwise.
+     */
+    protected boolean hasAttemptRemaining() {
+        return mCurrentRetryCount <= mMaxNumRetries;
+    }
+}
Index: app/src/main/java/com/duowan/mobile/netroid/Listener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/Listener.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/Listener.java	(revision )
@@ -0,0 +1,49 @@
+package com.duowan.mobile.netroid;
+
+/**
+ * Callback interface for delivering request status or response result.
+ * Note : all method are calls over UI thread.
+ * @param <T> Parsed type of this response
+ */
+public abstract class Listener<T> {
+	/** Inform when start to handle this Request. */
+	public void onPreExecute() {}
+
+	/** Inform when {@link Request} execute is finish,
+	 * whatever success or error or cancel, this callback
+	 * method always invoke if request is done. */
+	public void onFinish() {}
+
+	/** Called when response success. */
+	public abstract void onSuccess(T response);
+
+	/**
+	 * Callback method that an error has been occurred with the
+	 * provided error code and optional user-readable message.
+	 */
+	public void onError(NetroidError error) {}
+
+	/** Inform when the {@link Request} is truly cancelled. */
+	public void onCancel() {}
+
+	/**
+	 * Inform When the {@link Request} cache non-exist or expired,
+	 * this callback method is opposite by the onUsedCache(),
+	 * means the http retrieving will happen soon.
+	 */
+	public void onNetworking() {}
+
+	/** Inform when the cache already use,
+	 * it means http networking won't execute. */
+	public void onUsedCache() {}
+
+	/** Inform when {@link Request} execute is going to retry. */
+	public void onRetry() {}
+
+	/**
+	 * Inform when download progress change, this callback method only available
+	 * when request was {@link com.duowan.mobile.netroid.request.FileDownloadRequest}.
+	 */
+	public void onProgressChange(long fileSize, long downloadedSize) {
+	}
+}
Index: app/proguard-rules.pro
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/proguard-rules.pro	(revision )
+++ app/proguard-rules.pro	(revision )
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in D:\androidsdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
Index: app/src/main/java/com/duowan/mobile/example/netroid/netroid/Netroid.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/example/netroid/netroid/Netroid.java	(revision )
+++ app/src/main/java/com/duowan/mobile/example/netroid/netroid/Netroid.java	(revision )
@@ -0,0 +1,49 @@
+package com.duowan.mobile.example.netroid.netroid;
+
+import android.content.Context;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.os.Build;
+import com.duowan.mobile.netroid.Network;
+import com.duowan.mobile.netroid.RequestQueue;
+import com.duowan.mobile.netroid.cache.DiskCache;
+import com.duowan.mobile.netroid.stack.HttpClientStack;
+import com.duowan.mobile.netroid.stack.HttpStack;
+import com.duowan.mobile.netroid.stack.HurlStack;
+import com.duowan.mobile.netroid.toolbox.BasicNetwork;
+import org.apache.http.protocol.HTTP;
+
+public class Netroid {
+
+    /**
+     * Creates a default instance of the worker pool and calls {@link RequestQueue#start()} on it.
+     * @param context A {@link Context} to use for creating the cache dir.
+     * @return A started {@link RequestQueue} instance.
+     */
+    public static RequestQueue newRequestQueue(Context context, DiskCache cache) {
+		int poolSize = RequestQueue.DEFAULT_NETWORK_THREAD_POOL_SIZE;
+
+		HttpStack stack;
+		String userAgent = "netroid/0";
+		try {
+			String packageName = context.getPackageName();
+			PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);
+			userAgent = packageName + "/" + info.versionCode;
+		} catch (NameNotFoundException e) {
+		}
+
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
+			stack = new HurlStack(userAgent, null);
+		} else {
+			// Prior to Gingerbread, HttpUrlConnection was unreliable.
+			// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html
+			stack = new HttpClientStack(userAgent);
+		}
+
+		Network network = new BasicNetwork(stack, HTTP.UTF_8);
+		RequestQueue queue = new RequestQueue(network, poolSize, cache);
+		queue.start();
+
+        return queue;
+    }
+}
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/strings.xml	(revision )
+++ app/src/main/res/values/strings.xml	(revision )
@@ -0,0 +1,7 @@
+<resources>
+    <string name="app_name">Sercurity_BySound</string>
+    <string name="action_settings">Settings</string>
+
+    <string name="drawer_open">open</string>
+    <string name="drawer_close">close</string>
+</resources>
Index: app/src/main/java/com/duowan/mobile/netroid/stack/HttpClientStack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/stack/HttpClientStack.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/stack/HttpClientStack.java	(revision )
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.stack;
+
+import android.net.http.AndroidHttpClient;
+import com.duowan.mobile.netroid.AuthFailureError;
+import com.duowan.mobile.netroid.Request;
+import com.duowan.mobile.netroid.Request.Method;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.NameValuePair;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.*;
+import org.apache.http.entity.ByteArrayEntity;
+import org.apache.http.message.BasicNameValuePair;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.HTTP;
+
+import java.io.IOException;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * An HttpStack that performs request over an {@link HttpClient}.
+ */
+public class HttpClientStack implements HttpStack {
+    protected final HttpClient mClient;
+
+    public HttpClientStack(String userAgent) {
+        mClient = AndroidHttpClient.newInstance(userAgent);
+    }
+
+	public HttpClientStack(HttpClient client) {
+		mClient = client;
+	}
+
+    private static void addHeaders(HttpUriRequest httpRequest, Map<String, String> headers) {
+        for (String key : headers.keySet()) {
+            httpRequest.setHeader(key, headers.get(key));
+        }
+    }
+
+    @SuppressWarnings("unused")
+    private static List<NameValuePair> getPostParameterPairs(Map<String, String> postParams) {
+        List<NameValuePair> result = new ArrayList<NameValuePair>(postParams.size());
+        for (String key : postParams.keySet()) {
+            result.add(new BasicNameValuePair(key, postParams.get(key)));
+        }
+        return result;
+    }
+
+	@Override
+	public HttpResponse performRequest(Request<?> request) throws IOException, AuthFailureError {
+		HttpUriRequest httpRequest = createHttpRequest(request);
+		onPrepareRequest(httpRequest);
+		addHeaders(httpRequest, request.getHeaders());
+		HttpParams httpParams = httpRequest.getParams();
+		int timeoutMs = request.getTimeoutMs();
+		// TODO: Reevaluate this connection timeout based on more wide-scale
+		// data collection and possibly different for wifi vs. 3G.
+		HttpConnectionParams.setConnectionTimeout(httpParams, 5000);
+		HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);
+		return mClient.execute(httpRequest);
+	}
+
+    /**
+     * Creates the appropriate subclass of HttpUriRequest for passed in request.
+     */
+	private static HttpUriRequest createHttpRequest(Request<?> request) throws AuthFailureError {
+        switch (request.getMethod()) {
+            case Method.GET:
+                return new HttpGet(request.getUrl());
+            case Method.DELETE:
+                return new HttpDelete(request.getUrl());
+            case Method.POST: {
+                HttpPost postRequest = new HttpPost(request.getUrl());
+                postRequest.addHeader(HTTP.CONTENT_TYPE, request.getBodyContentType());
+                setEntityIfNonEmptyBody(postRequest, request);
+                return postRequest;
+            }
+            case Method.PUT: {
+                HttpPut putRequest = new HttpPut(request.getUrl());
+                putRequest.addHeader(HTTP.CONTENT_TYPE, request.getBodyContentType());
+                setEntityIfNonEmptyBody(putRequest, request);
+                return putRequest;
+            }
+            case Method.HEAD:
+                return new HttpHead(request.getUrl());
+            case Method.OPTIONS:
+                return new HttpOptions(request.getUrl());
+            case Method.TRACE:
+                return new HttpTrace(request.getUrl());
+            case Method.PATCH: {
+                HttpPatch patchRequest = new HttpPatch(request.getUrl());
+                patchRequest.addHeader(HTTP.CONTENT_TYPE, request.getBodyContentType());
+                setEntityIfNonEmptyBody(patchRequest, request);
+                return patchRequest;
+            }
+            default:
+                throw new IllegalStateException("Unknown request method.");
+        }
+    }
+
+    private static void setEntityIfNonEmptyBody(HttpEntityEnclosingRequestBase httpRequest,
+            Request<?> request) throws AuthFailureError {
+        byte[] body = request.getBody();
+        if (body != null) {
+            HttpEntity entity = new ByteArrayEntity(body);
+            httpRequest.setEntity(entity);
+        }
+    }
+
+    /**
+     * Called before the request is executed using the underlying HttpClient.
+     *
+     * <p>Overwrite in subclasses to augment the request.</p>
+     */
+    protected void onPrepareRequest(HttpUriRequest request) throws IOException {
+        request.addHeader("Accept-Encoding", "gzip");
+	}
+
+	/**
+	 * The HttpPatch class does not exist in the Android framework, so this has been defined here.
+	 */
+	public static final class HttpPatch extends HttpEntityEnclosingRequestBase {
+		public final static String METHOD_NAME = "PATCH";
+
+		public HttpPatch() {
+			super();
+		}
+
+		public HttpPatch(final URI uri) {
+			super();
+			setURI(uri);
+		}
+
+		/**
+		 * @throws IllegalArgumentException if the uri is invalid.
+		 */
+		public HttpPatch(final String uri) {
+			super();
+			setURI(URI.create(uri));
+		}
+
+		@Override
+		public String getMethod() {
+			return METHOD_NAME;
+		}
+	}
+}
Index: app/src/main/java/com/duowan/mobile/netroid/CacheDispatcher.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/CacheDispatcher.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/CacheDispatcher.java	(revision )
@@ -0,0 +1,159 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+import android.os.Process;
+import com.duowan.mobile.netroid.cache.DiskCache;
+
+import java.util.concurrent.BlockingQueue;
+
+/**
+ * Provides a thread for performing cache triage on a queue of requests.
+ *
+ * Requests added to the specified cache queue are resolved from cache.
+ * Any deliverable response is posted back to the caller via a
+ * {@link Delivery}. Cache misses and responses that require
+ * refresh are enqueued on the specified network queue for processing
+ * by a {@link NetworkDispatcher}.
+ */
+@SuppressWarnings("rawtypes")
+public class CacheDispatcher extends Thread {
+
+    private static final boolean DEBUG = NetroidLog.DEBUG;
+
+    /** The queue of requests coming in for triage. */
+    private final BlockingQueue<Request> mCacheQueue;
+
+    /** The queue of requests going out to the network. */
+    private final BlockingQueue<Request> mNetworkQueue;
+
+	/** The cache to read from. */
+    private final DiskCache mCache;
+
+    /** For posting responses. */
+    private final Delivery mDelivery;
+
+    /** Used for telling us to die. */
+    private volatile boolean mQuit = false;
+
+    /**
+     * Creates a new cache triage dispatcher thread.  You must call {@link #start()}
+     * in order to begin processing.
+     *
+     * @param cacheQueue Queue of incoming requests for triage
+     * @param networkQueue Queue to post requests that require network to
+     * @param cache Cache interface to use for resolution
+     * @param delivery Delivery interface to use for posting responses
+     */
+    public CacheDispatcher(BlockingQueue<Request> cacheQueue, BlockingQueue<Request> networkQueue,
+						   DiskCache cache, Delivery delivery) {
+		mCache = cache;
+		mDelivery = delivery;
+		mCacheQueue = cacheQueue;
+		mNetworkQueue = networkQueue;
+	}
+
+    /**
+     * Forces this dispatcher to quit immediately.  If any requests are still in
+     * the queue, they are not guaranteed to be processed.
+     */
+    public void quit() {
+        mQuit = true;
+        interrupt();
+    }
+
+    @Override
+    public void run() {
+        if (DEBUG) NetroidLog.v("start new dispatcher");
+        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
+
+        // Make a blocking call to initialize the cache.
+		if (mCache != null) mCache.initialize();
+
+        while (true) {
+            try {
+                // Get a request from the cache triage queue, blocking until
+                // at least one is available.
+                final Request request = mCacheQueue.take();
+				request.addMarker("cache-queue-take");
+				mDelivery.postPreExecute(request);
+
+                // If the request has been canceled, don't bother dispatching it.
+                if (request.isCanceled()) {
+                    request.finish("cache-discard-canceled");
+					mDelivery.postCancel(request);
+					mDelivery.postFinish(request);
+                    continue;
+                }
+
+				// Attempt to retrieve this item from cache.
+				DiskCache.Entry entry = mCache != null ? mCache.getEntry(request.getCacheKey()) : null;
+				if (entry == null) {
+					request.addMarker("cache-miss");
+					// Cache miss; send off to the network dispatcher.
+					mNetworkQueue.put(request);
+					mDelivery.postNetworking(request);
+					continue;
+				}
+
+                // If it is completely expired, just send it to the network.
+                if (entry.isExpired()) {
+					request.addMarker("cache-hit-expired");
+                    mNetworkQueue.put(request);
+					mDelivery.postNetworking(request);
+					continue;
+                }
+
+                // We have a cache hit; parse its data for delivery back to the request.
+                request.addMarker("cache-hit");
+                Response<?> response = request.parseNetworkResponse(new NetworkResponse(entry.data, entry.charset));
+                request.addMarker("cache-hit-parsed");
+				mDelivery.postUsedCache(request);
+
+                if (!entry.refreshNeeded()) {
+                    // Completely unexpired cache hit. Just deliver the response.
+                    mDelivery.postResponse(request, response);
+                } else {
+                    // Soft-expired cache hit. We can deliver the cached response,
+                    // but we need to also send the request to the network for
+                    // refreshing.
+                    request.addMarker("cache-hit-refresh-needed");
+
+                    // Mark the response as intermediate.
+                    response.intermediate = true;
+
+                    // Post the intermediate response back to the user and have
+                    // the delivery then forward the request along to the network.
+                    mDelivery.postResponse(request, response, new Runnable() {
+                        @Override
+                        public void run() {
+                            try {
+                                mNetworkQueue.put(request);
+                            } catch (InterruptedException e) {
+                                // Not much we can do about this.
+                            }
+                        }
+                    });
+                }
+            } catch (InterruptedException e) {
+                // We may have been interrupted because it was time to quit.
+                if (mQuit) return;
+            }
+        }
+    }
+
+}
Index: gradle.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- gradle.properties	(revision )
+++ gradle.properties	(revision )
@@ -0,0 +1,18 @@
+# Project-wide Gradle settings.
+
+# IDE (e.g. Android Studio) users:
+# Gradle settings configured through the IDE *will override*
+# any settings specified in this file.
+
+# For more details on how to configure your build environment visit
+# http://www.gradle.org/docs/current/userguide/build_environment.html
+
+# Specifies the JVM arguments used for the daemon process.
+# The setting is particularly useful for tweaking memory settings.
+# Default value: -Xmx10248m -XX:MaxPermSize=256m
+# org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8
+
+# When configured, Gradle will run in incubating parallel mode.
+# This option should only be used with decoupled projects. More details, visit
+# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
+# org.gradle.parallel=true
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/toolbox/FileDownloader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/toolbox/FileDownloader.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/toolbox/FileDownloader.java	(revision )
@@ -0,0 +1,301 @@
+package com.duowan.mobile.netroid.toolbox;
+
+import android.os.Looper;
+import com.duowan.mobile.netroid.Listener;
+import com.duowan.mobile.netroid.NetroidError;
+import com.duowan.mobile.netroid.RequestQueue;
+import com.duowan.mobile.netroid.request.FileDownloadRequest;
+
+import java.util.LinkedList;
+
+/**
+ * This class provided continuous transmission on the breakpoint download task management utilities.
+ * As long as the site support(enable 'Content-Range' Header), we'd retrieve last download temporary
+ * file when we start to download, fetch the temporary file length as current Range begin point,
+ * then the last downloaded data effective.
+ * Sadly is when the server-side didn't support download by Range,
+ * we'll delete the temporary file and start download from beginning.
+ *
+ * Usage: like {@link ImageLoader}, the best way to use this class is create by {@link RequestQueue}
+ * and stand Singleton, just get the only one instance to do everything in anywhere.
+ * To start a new download request, invoke the {@link FileDownloader#add(String, String, com.duowan.mobile.netroid.Listener)}
+ * to pass in the task parameters, it will deploy to the Task Queue and execute as soon as possible.
+ *
+ * Note: For the multithreading and bandwidth limit reason,
+ * we normally start two parallel tasks to download data,
+ * don't over three, and remember keep one idle thread to
+ * perform common http request at least.
+ */
+public class FileDownloader {
+	/** RequestQueue for dispatching DownloadRequest. */
+	private final RequestQueue mRequestQueue;
+
+	/** The parallel task count, recommend less than 3. */
+	private final int mParallelTaskCount;
+
+	/** The linked Task Queue. */
+	private final LinkedList<DownloadController> mTaskQueue;
+
+	/**
+	 * Construct Downloader and init the Task Queue.
+	 * @param queue The RequestQueue for dispatching Download task.
+	 * @param parallelTaskCount
+	 * 				Allows parallel task count,
+	 * 				don't forget the value must less than ThreadPoolSize of the RequestQueue.
+	 */
+	public FileDownloader(RequestQueue queue, int parallelTaskCount) {
+		if (parallelTaskCount >= queue.getThreadPoolSize()) {
+			throw new IllegalArgumentException("parallelTaskCount[" + parallelTaskCount
+					+ "] must less than threadPoolSize[" + queue.getThreadPoolSize() + "] of the RequestQueue.");
+		}
+
+		mTaskQueue = new LinkedList<DownloadController>();
+		mParallelTaskCount = parallelTaskCount;
+		mRequestQueue = queue;
+	}
+
+	/**
+	 * Create a new download request, this request might not run immediately because the parallel task limitation,
+	 * you can check the status by the {@link DownloadController} which you got after invoke this method.
+	 *
+	 * Note: don't perform this method twice or more with same parameters, because we didn't check for
+	 * duplicate tasks, it rely on developer done.
+	 *
+	 * Note: this method should invoke in the main thread.
+	 *
+	 * @param storeFilePath Once download successed, we'll find it by the store file path.
+	 * @param url The download url.
+	 * @param listener The event callback by status;
+	 * @return The task controller allows pause or resume or discard operation.
+	 */
+	public DownloadController add(String storeFilePath, String url, Listener<Void> listener) {
+		// only fulfill requests that were initiated from the main thread.(reason for the Delivery?)
+		throwIfNotOnMainThread();
+
+		DownloadController controller = new DownloadController(storeFilePath, url, listener);
+		synchronized (mTaskQueue) {
+			mTaskQueue.add(controller);
+		}
+		schedule();
+		return controller;
+	}
+
+	/**
+	 * Scanning the Task Queue, fetch a {@link DownloadController} who match the two parameters.
+	 * @param storeFilePath The storeFilePath to compare.
+	 * @param url The url to compare.
+	 * @return The matched {@link DownloadController}.
+	 */
+	public DownloadController get(String storeFilePath, String url) {
+		synchronized (mTaskQueue) {
+			for (DownloadController controller : mTaskQueue) {
+				if (controller.mStoreFilePath.equals(storeFilePath) &&
+						controller.mUrl.equals(url)) return controller;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Traverse the Task Queue, count the running task then deploy more if it can be.
+	 */
+	private void schedule() {
+		// make sure only one thread can manipulate the Task Queue.
+		synchronized (mTaskQueue) {
+			// counting ran task.
+			int parallelTaskCount = 0;
+			for (DownloadController controller : mTaskQueue) {
+				if (controller.isDownloading()) parallelTaskCount++;
+			}
+			if (parallelTaskCount >= mParallelTaskCount) return;
+
+			// try to deploy all Task if they're await.
+			for (DownloadController controller : mTaskQueue) {
+				if (controller.deploy() && ++parallelTaskCount == mParallelTaskCount) return;
+			}
+		}
+	}
+
+	/**
+	 * Remove the controller from the Task Queue, re-schedule to make those waiting task deploys.
+	 * @param controller The controller which will be remove.
+	 */
+	private void remove(DownloadController controller) {
+		// also make sure one thread operation
+		synchronized (mTaskQueue) {
+			mTaskQueue.remove(controller);
+		}
+		schedule();
+	}
+
+	/**
+	 * Clear all tasks, make the Task Queue empty.
+	 */
+	public void clearAll() {
+		// make sure only one thread can manipulate the Task Queue.
+		synchronized (mTaskQueue) {
+			while (mTaskQueue.size() > 0) {
+				mTaskQueue.get(0).discard();
+			}
+		}
+	}
+
+	private void throwIfNotOnMainThread() {
+		if (Looper.myLooper() != Looper.getMainLooper()) {
+			throw new IllegalStateException("FileDownloader must be invoked from the main thread.");
+		}
+	}
+
+	/**
+	 * This method can override by developer to change download behaviour,
+	 * such as add customize headers or handle the response himself. <br/>
+	 * Note : before you override this, make sure you are understood the {@link FileDownloadRequest} very well.
+	 */
+	public FileDownloadRequest buildRequest(String storeFilePath, String url) {
+		return new FileDownloadRequest(storeFilePath, url);
+	}
+
+	/**
+	 * This class included all such as PAUSE, RESUME, DISCARD to manipulating download task,
+	 * it created by {@link FileDownloader#add(String, String, com.duowan.mobile.netroid.Listener)},
+	 * offer three params to constructing {@link FileDownloadRequest} then perform http downloading,
+	 * you can check the download status whenever you want to know.
+	 */
+	public class DownloadController {
+		// Persist the Request createing params for re-create it when pause operation gone.
+		private Listener<Void> mListener;
+		private String mStoreFilePath;
+		private String mUrl;
+
+		// The download request.
+		private FileDownloadRequest mRequest;
+
+		private int mStatus;
+		public static final int STATUS_WAITING = 0;
+		public static final int STATUS_DOWNLOADING = 1;
+		public static final int STATUS_PAUSE = 2;
+		public static final int STATUS_SUCCESS = 3;
+		public static final int STATUS_DISCARD = 4;
+
+		private DownloadController(String storeFilePath, String url, Listener<Void> listener) {
+			mStoreFilePath = storeFilePath;
+			mListener = listener;
+			mUrl = url;
+		}
+
+		/**
+		 * For the parallel reason, only the {@link FileDownloader#schedule()} can call this method.
+		 * @return true if deploy is successed.
+		 */
+		private boolean deploy() {
+			if (mStatus != STATUS_WAITING) return false;
+
+			mRequest = buildRequest(mStoreFilePath, mUrl);
+
+			// we create a Listener to wrapping that Listener which developer specified,
+			// for the onFinish(), onSuccess(), onError() won't call when request was cancel reason.
+			mRequest.setListener(new Listener<Void>() {
+				boolean isCanceled;
+
+				@Override
+				public void onPreExecute() {
+					mListener.onPreExecute();
+				}
+
+				@Override
+				public void onFinish() {
+					// we don't inform FINISH when it was cancel.
+					if (!isCanceled) {
+						mStatus = STATUS_SUCCESS;
+						mListener.onFinish();
+						// when request was FINISH, remove the task and re-schedule Task Queue.
+						remove(DownloadController.this);
+					}
+				}
+
+				@Override
+				public void onSuccess(Void response) {
+					// we don't inform SUCCESS when it was cancel.
+					if (!isCanceled) mListener.onSuccess(response);
+				}
+
+				@Override
+				public void onError(NetroidError error) {
+					// we don't inform ERROR when it was cancel.
+					if (!isCanceled) mListener.onError(error);
+				}
+
+				@Override
+				public void onCancel() {
+					mListener.onCancel();
+					isCanceled = true;
+				}
+
+				@Override
+				public void onProgressChange(long fileSize, long downloadedSize) {
+					mListener.onProgressChange(fileSize, downloadedSize);
+				}
+			});
+
+			mStatus = STATUS_DOWNLOADING;
+			mRequestQueue.add(mRequest);
+			return true;
+		}
+
+		public int getStatus() {
+			return mStatus;
+		}
+
+		public boolean isDownloading() {
+			return mStatus == STATUS_DOWNLOADING;
+		}
+
+		/**
+		 * Pause this task when it status was DOWNLOADING, in fact, we just marked the request should be cancel,
+		 * http request cannot stop immediately, we assume it will finish soon, thus we set the status as PAUSE,
+		 * let Task Queue deploy a new Request, that will cause parallel tasks growing beyond maximum task count,
+		 * but it doesn't matter, we believe that situation never longer.
+		 * @return true if did the pause operation.
+		 */
+		public boolean pause() {
+			if (mStatus == STATUS_DOWNLOADING) {
+				mStatus = STATUS_PAUSE;
+				mRequest.cancel();
+				schedule();
+				return true;
+			}
+			return false;
+		}
+
+		/**
+		 * Resume this task when it status was PAUSE, we will turn the status as WAITING, then re-schedule the Task Queue,
+		 * if parallel counter take an idle place, this task will re-deploy instantly,
+		 * if not, the status will stay WAITING till idle occur.
+		 * @return true if did the resume operation.
+		 */
+		public boolean resume() {
+			if (mStatus == STATUS_PAUSE) {
+				mStatus = STATUS_WAITING;
+				schedule();
+				return true;
+			}
+			return false;
+		}
+
+		/**
+		 * We will discard this task from the Task Queue, if the status was DOWNLOADING,
+		 * we first cancel the Request, then remove task from the Task Queue,
+		 * also re-schedule the Task Queue at last.
+		 * @return true if did the discard operation.
+		 */
+		public boolean discard() {
+			if (mStatus == STATUS_DISCARD) return false;
+			if (mStatus == STATUS_SUCCESS) return false;
+			if (mStatus == STATUS_DOWNLOADING) mRequest.cancel();
+			mStatus = STATUS_DISCARD;
+			remove(this);
+			return true;
+		}
+	}
+
+}
Index: app/src/main/res/drawable/background_tab.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/drawable/background_tab.xml	(revision )
+++ app/src/main/res/drawable/background_tab.xml	(revision )
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android" android:exitFadeDuration="@android:integer/config_shortAnimTime">
+
+    <item android:state_pressed="true" android:drawable="@color/background_tab_pressed" />
+    <item android:state_focused="true" android:drawable="@color/background_tab_pressed"/>
+    <item android:drawable="@android:color/transparent"/>
+
+</selector>
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/toolbox/ImageLoader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/toolbox/ImageLoader.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/toolbox/ImageLoader.java	(revision )
@@ -0,0 +1,487 @@
+/**
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.duowan.mobile.netroid.toolbox;
+
+import android.graphics.Bitmap;
+import android.os.Handler;
+import android.os.Looper;
+import android.widget.ImageView;
+import com.duowan.mobile.netroid.Listener;
+import com.duowan.mobile.netroid.NetroidError;
+import com.duowan.mobile.netroid.Request;
+import com.duowan.mobile.netroid.RequestQueue;
+import com.duowan.mobile.netroid.request.ImageRequest;
+
+import java.util.HashMap;
+import java.util.LinkedList;
+
+/**
+ * Helper that handles loading images from remote URLs.
+ *
+ * The simple way to use this class is to call {@link ImageLoader#get(String, ImageListener)}
+ * and to pass in the default image listener provided by
+ * {@link ImageLoader#getImageListener(ImageView, int, int)}. Note that all function calls to
+ * this class must be made from the main thead, and all responses will be delivered to the main
+ * thread as well.
+ */
+public abstract class ImageLoader {
+    /** RequestQueue for dispatching ImageRequests onto. */
+    private final RequestQueue mRequestQueue;
+
+    /** Amount of time to wait after first response arrives before delivering all responses. */
+    private int mBatchResponseDelayMs = 100;
+
+	/** The cache implementation to be used as an L1 cache before calling into volley. */
+	private final ImageCache mCache;
+
+    /**
+     * HashMap of Cache keys -> BatchedImageRequest used to track in-flight requests so
+     * that we can coalesce multiple requests to the same URL into a single network request.
+     */
+    private final HashMap<String, BatchedImageRequest> mInFlightRequests =
+            new HashMap<String, BatchedImageRequest>();
+
+    /** HashMap of the currently pending responses (waiting to be delivered). */
+    private final HashMap<String, BatchedImageRequest> mBatchedResponses =
+            new HashMap<String, BatchedImageRequest>();
+
+    /** Handler to the main thread. */
+    private final Handler mHandler = new Handler(Looper.getMainLooper());
+
+    /** Runnable for in-flight response delivery. */
+    private Runnable mRunnable;
+
+	/**
+	 * Simple cache adapter interface. If provided to the ImageLoader, it
+	 * will be used as an L1 cache before dispatch to Netroid. Implementations
+	 * must not block. Implementation with an LruCache is recommended.
+	 */
+	public interface ImageCache {
+		public Bitmap getBitmap(String url);
+		public void putBitmap(String url, Bitmap bitmap);
+	}
+
+    /**
+     * Constructs a new ImageLoader.
+     * @param queue The RequestQueue to use for making image requests.
+	 * @param imageCache The cache to use as an L1 cache.
+     */
+    public ImageLoader(RequestQueue queue, ImageCache imageCache) {
+		mRequestQueue = queue;
+		mCache = imageCache;
+	}
+
+    /**
+     * The default implementation of ImageListener which handles basic functionality
+     * of showing a default image until the network response is received, at which point
+     * it will switch to either the actual image or the error image.
+     * @param imageView The imageView that the listener is associated with.
+     * @param defaultImageResId Default image resource ID to use, or 0 if it doesn't exist.
+     * @param errorImageResId Error image resource ID to use, or 0 if it doesn't exist.
+     */
+    public static ImageListener getImageListener(final ImageView imageView,
+            final int defaultImageResId, final int errorImageResId) {
+        return new ImageListener() {
+            @Override
+            public void onError(NetroidError error) {
+                if (errorImageResId != 0) {
+                    imageView.setImageResource(errorImageResId);
+                }
+            }
+
+            @Override
+            public void onSuccess(ImageContainer response, boolean isImmediate) {
+                if (response.getBitmap() != null) {
+                    imageView.setImageBitmap(response.getBitmap());
+                } else if (defaultImageResId != 0) {
+                    imageView.setImageResource(defaultImageResId);
+                }
+            }
+        };
+    }
+
+    /**
+     * Interface for the response handlers on image requests.
+     *
+     * The call flow is this:
+     * 1. Upon being  attached to a request, onSuccess(response, true) will
+     * be invoked to reflect any cached data that was already available. If the
+     * data was available, response.getBitmap() will be non-null.
+     *
+     * 2. After a network response returns, only one of the following cases will happen:
+     *   - onSuccess(response, false) will be called if the image was loaded.
+     *   or
+     *   - onError will be called if there was an error loading the image.
+     */
+    public interface ImageListener {
+        /**
+         * Listens for non-error changes to the loading of the image request.
+         *
+         * @param response Holds all information pertaining to the request, as well
+         * as the bitmap (if it is loaded).
+         * @param isImmediate True if this was called during ImageLoader.get() variants.
+         * This can be used to differentiate between a cached image loading and a network
+         * image loading in order to, for example, run an animation to fade in network loaded
+         * images.
+         */
+        public void onSuccess(ImageContainer response, boolean isImmediate);
+
+		/**
+		 * Callback method that an error has been occurred with the
+		 * provided error code and optional user-readable message.
+		 */
+		public void onError(NetroidError error);
+    }
+
+	/**
+	 * Checks if the item is available in the cache.
+	 * @param requestUrl The url of the remote image
+	 * @param maxWidth The maximum width of the returned image.
+	 * @param maxHeight The maximum height of the returned image.
+	 * @return True if the item exists in cache, false otherwise.
+	 */
+	public boolean isCached(String requestUrl, int maxWidth, int maxHeight) {
+		if (mCache == null) return false;
+		throwIfNotOnMainThread();
+
+		String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight);
+		return mCache.getBitmap(cacheKey) != null;
+	}
+
+    /**
+     * Returns an ImageContainer for the requested URL.
+     *
+     * The ImageContainer will contain either the specified default bitmap or the loaded bitmap.
+     * If the default was returned, the {@link ImageLoader} will be invoked when the
+     * request is fulfilled.
+     *
+     * @param requestUrl The URL of the image to be loaded.
+     * @param listener The listener to call when the remote image is loaded.
+     */
+    public ImageContainer get(String requestUrl, final ImageListener listener) {
+        return get(requestUrl, listener, 0, 0);
+    }
+
+    /**
+     * Issues a bitmap request with the given URL if that image is not available
+     * in the cache, and returns a bitmap container that contains all of the data
+     * relating to the request (as well as the default image if the requested
+     * image is not available).
+     * @param requestUrl The url of the remote image
+     * @param imageListener The listener to call when the remote image is loaded
+     * @param maxWidth The maximum width of the returned image.
+     * @param maxHeight The maximum height of the returned image.
+     * @return A container object that contains all of the properties of the request, as well as
+     *     the currently available image (default if remote is not loaded).
+     */
+    public ImageContainer get(String requestUrl, ImageListener imageListener,
+							  int maxWidth, int maxHeight) {
+        // only fulfill requests that were initiated from the main thread.
+        throwIfNotOnMainThread();
+
+		final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight);
+
+		// Try to look up the request in the cache of remote images.
+		if (mCache != null) {
+			Bitmap cachedBitmap = mCache.getBitmap(cacheKey);
+			if (cachedBitmap != null) {
+				// Return the cached bitmap.
+				ImageContainer container = new ImageContainer(cachedBitmap, requestUrl, null, null);
+				imageListener.onSuccess(container, true);
+				return container;
+			}
+		}
+
+		// The bitmap did not exist in the cache, fetch it!
+        ImageContainer imageContainer =
+				new ImageContainer(null, requestUrl, cacheKey, imageListener);
+
+		// Request doesn't use memory cache, will going to request, whether load by disk cache or network are not fast,
+		// update the caller to let them know that they should use the default bitmap.
+        imageListener.onSuccess(imageContainer, true);
+
+        // Check to see if a request is already in-flight.
+        BatchedImageRequest request = mInFlightRequests.get(cacheKey);
+        if (request != null) {
+            // If it is, add this request to the list of listeners.
+			request.addContainer(imageContainer);
+            return imageContainer;
+        }
+
+        // The request is not already in flight. Send the new request to the network and track it.
+		ImageRequest newRequest = buildRequest(requestUrl, maxWidth, maxHeight);
+		newRequest.setListener(new Listener<Bitmap>() {
+			@Override
+			public void onSuccess(Bitmap response) {
+				onGetImageSuccess(cacheKey, response);
+			}
+
+			@Override
+			public void onError(NetroidError error) {
+				onGetImageError(cacheKey, error);
+			}
+		});
+        mRequestQueue.add(newRequest);
+		
+        mInFlightRequests.put(cacheKey,
+				new BatchedImageRequest(newRequest, imageContainer));
+        return imageContainer;
+    }
+	
+	public abstract ImageRequest buildRequest(String requestUrl, int maxWidth, int maxHeight);
+
+    /**
+     * Sets the amount of time to wait after the first response arrives before delivering all
+     * responses. Batching can be disabled entirely by passing in 0.
+     * @param newBatchedResponseDelayMs The time in milliseconds to wait.
+     */
+    public void setBatchedResponseDelay(int newBatchedResponseDelayMs) {
+        mBatchResponseDelayMs = newBatchedResponseDelayMs;
+    }
+
+    /**
+     * Handler for when an image was successfully loaded.
+     * @param cacheKey The cache key that is associated with the image request.
+     * @param response The bitmap that was returned from the network.
+     */
+    private void onGetImageSuccess(String cacheKey, Bitmap response) {
+		// cache the image that was fetched.
+		if (mCache != null) mCache.putBitmap(cacheKey, response);
+
+		// remove the request from the list of in-flight requests.
+		BatchedImageRequest request = mInFlightRequests.remove(cacheKey);
+
+		if (request != null) {
+			// Update the response bitmap.
+			request.mResponseBitmap = response;
+
+			// Send the batched response
+			batchResponse(cacheKey, request);
+		}
+	}
+
+    /**
+     * Handler for when an image failed to load.
+     * @param cacheKey The cache key that is associated with the image request.
+     */
+    private void onGetImageError(String cacheKey, NetroidError error) {
+        // Notify the requesters that something failed via a null result.
+        // Remove this request from the list of in-flight requests.
+        BatchedImageRequest request = mInFlightRequests.remove(cacheKey);
+
+		if (request != null) {
+			// Set the error for this request
+			request.setError(error);
+
+			// Send the batched response
+			batchResponse(cacheKey, request);
+		}
+	}
+
+    /**
+     * Container object for all of the data surrounding an image request.
+     */
+    public class ImageContainer {
+        /**
+         * The most relevant bitmap for the container. If the image was in cache, the
+         * Holder to use for the final bitmap (the one that pairs to the requested URL).
+         */
+        private Bitmap mBitmap;
+
+        private final ImageListener mListener;
+
+        /** The cache key that was associated with the request */
+        private final String mCacheKey;
+
+        /** The request URL that was specified */
+        private final String mRequestUrl;
+
+        /**
+         * Constructs a BitmapContainer object.
+         * @param bitmap The final bitmap (if it exists).
+         * @param requestUrl The requested URL for this container.
+         * @param cacheKey The cache key that identifies the requested URL for this container.
+         */
+        public ImageContainer(Bitmap bitmap, String requestUrl,
+                String cacheKey, ImageListener listener) {
+            mBitmap = bitmap;
+            mRequestUrl = requestUrl;
+            mCacheKey = cacheKey;
+            mListener = listener;
+        }
+
+        /**
+         * Releases interest in the in-flight request (and cancels it if no one else is listening).
+         */
+        public void cancelRequest() {
+            if (mListener == null) {
+                return;
+            }
+
+            BatchedImageRequest request = mInFlightRequests.get(mCacheKey);
+            if (request != null) {
+                boolean canceled = request.removeContainerAndCancelIfNecessary(this);
+                if (canceled) {
+                    mInFlightRequests.remove(mCacheKey);
+                }
+            } else {
+                // check to see if it is already batched for delivery.
+                request = mBatchedResponses.get(mCacheKey);
+                if (request != null) {
+                    request.removeContainerAndCancelIfNecessary(this);
+                    if (request.mContainers.size() == 0) {
+                        mBatchedResponses.remove(mCacheKey);
+                    }
+                }
+            }
+        }
+
+        /**
+         * Returns the bitmap associated with the request URL if it has been loaded, null otherwise.
+         */
+        public Bitmap getBitmap() {
+            return mBitmap;
+        }
+
+        /**
+         * Returns the requested URL for this container.
+         */
+        public String getRequestUrl() {
+            return mRequestUrl;
+        }
+    }
+
+    /**
+     * Wrapper class used to map a Request to the set of active ImageContainer objects that are
+     * interested in its results.
+     */
+    private class BatchedImageRequest {
+        /** The request being tracked */
+        private final Request<?> mRequest;
+
+        /** The result of the request being tracked by this item */
+        private Bitmap mResponseBitmap;
+
+        /** Error if one occurred for this response */
+        private NetroidError mError;
+
+        /** List of all of the active ImageContainers that are interested in the request */
+        private final LinkedList<ImageContainer> mContainers = new LinkedList<ImageContainer>();
+
+        /**
+         * Constructs a new BatchedImageRequest object
+         * @param request The request being tracked
+         * @param container The ImageContainer of the person who initiated the request.
+         */
+        public BatchedImageRequest(Request<?> request, ImageContainer container) {
+            mRequest = request;
+            mContainers.add(container);
+        }
+
+        /**
+         * Set the error for this response
+         */
+        public void setError(NetroidError error) {
+            mError = error;
+        }
+
+        /**
+         * Get the error for this response
+         */
+        public NetroidError getError() {
+            return mError;
+        }
+
+        /**
+         * Adds another ImageContainer to the list of those interested in the results of
+         * the request.
+         */
+        public void addContainer(ImageContainer container) {
+            mContainers.add(container);
+        }
+
+        /**
+         * Detatches the bitmap container from the request and cancels the request if no one is
+         * left listening.
+         * @param container The container to remove from the list
+         * @return True if the request was canceled, false otherwise.
+         */
+        public boolean removeContainerAndCancelIfNecessary(ImageContainer container) {
+            mContainers.remove(container);
+            if (mContainers.size() == 0) {
+                mRequest.cancel();
+                return true;
+            }
+            return false;
+        }
+    }
+
+    /**
+     * Starts the runnable for batched delivery of responses if it is not already started.
+     * @param cacheKey The cacheKey of the response being delivered.
+     * @param request The BatchedImageRequest to be delivered.
+     */
+    private void batchResponse(String cacheKey, BatchedImageRequest request) {
+        mBatchedResponses.put(cacheKey, request);
+        // If we don't already have a batch delivery runnable in flight, make a new one.
+        // Note that this will be used to deliver responses to all callers in mBatchedResponses.
+        if (mRunnable == null) {
+            mRunnable = new Runnable() {
+                @Override
+                public void run() {
+                    for (BatchedImageRequest bir : mBatchedResponses.values()) {
+                        for (ImageContainer container : bir.mContainers) {
+                            // If one of the callers in the batched request canceled the request
+                            // after the response was received but before it was delivered,
+                            // skip them.
+                            if (container.mListener == null) {
+                                continue;
+                            }
+                            if (bir.getError() == null) {
+                                container.mBitmap = bir.mResponseBitmap;
+                                container.mListener.onSuccess(container, false);
+                            } else {
+                                container.mListener.onError(bir.getError());
+                            }
+                        }
+                    }
+                    mBatchedResponses.clear();
+                    mRunnable = null;
+                }
+
+            };
+            // Post the runnable.
+            mHandler.postDelayed(mRunnable, mBatchResponseDelayMs);
+        }
+    }
+
+    private void throwIfNotOnMainThread() {
+        if (Looper.myLooper() != Looper.getMainLooper()) {
+            throw new IllegalStateException("ImageLoader must be invoked from the main thread.");
+        }
+    }
+
+    /**
+     * Use url+width+height to Creates a cacheKey that identifies the request.
+     * @param url The URL of the request.
+     * @param maxWidth The max-width of the output.
+     * @param maxHeight The max-height of the output.
+     */
+    public static String getCacheKey(String url, int maxWidth, int maxHeight) {
+		return "#W" + maxWidth + "#H" + maxHeight + url;
+	}
+
+}
Index: app/src/main/java/com/duowan/mobile/netroid/RetryPolicy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/RetryPolicy.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/RetryPolicy.java	(revision )
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+/**
+ * Retry policy for a request.
+ */
+public interface RetryPolicy {
+
+    /**
+     * Returns the current timeout (used for logging).
+     */
+    public int getCurrentTimeout();
+
+    /**
+     * Returns the current retry count (used for logging).
+     */
+    public int getCurrentRetryCount();
+
+    /**
+     * Prepares for the next retry by applying a backoff to the timeout.
+     * @param error The error code of the last attempt.
+     * @throws NetroidError In the event that the retry could not be performed (for example if we
+     * ran out of attempts), the passed in error is thrown.
+     */
+    public void retry(NetroidError error) throws NetroidError;
+}
Index: app/src/main/java/com/duowan/mobile/netroid/NetworkDispatcher.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/NetworkDispatcher.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/NetworkDispatcher.java	(revision )
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+import android.os.Process;
+import com.duowan.mobile.netroid.cache.DiskCache;
+
+import java.util.concurrent.BlockingQueue;
+
+/**
+ * Provides a thread for performing network dispatch from a queue of requests.
+ *
+ * Requests added to the specified queue are processed from the network via a
+ * specified {@link Network} interface. Responses are committed to cache, if
+ * eligible, using a specified {@link com.duowan.mobile.netroid.cache.DiskCache} interface.
+ * Valid responses and errors are posted back to the caller via a {@link Delivery}.
+ */
+@SuppressWarnings("rawtypes")
+public class NetworkDispatcher extends Thread {
+    /** The queue of requests to service. */
+    private final BlockingQueue<Request> mQueue;
+
+    /** The network interface for processing requests. */
+    private final Network mNetwork;
+
+	/** The cache to write to. */
+    private final DiskCache mCache;
+
+	/** For posting responses and errors. */
+    private final Delivery mDelivery;
+
+	/** Used for telling us to die. */
+    private volatile boolean mQuit = false;
+
+    /**
+     * Creates a new network dispatcher thread.  You must call {@link #start()}
+     * in order to begin processing.
+     *
+     * @param queue Queue of incoming requests for triage
+     * @param network Network interface to use for performing requests
+	 * @param cache Cache interface to use for writing responses to cache
+     * @param delivery Delivery interface to use for posting responses
+     */
+    public NetworkDispatcher(BlockingQueue<Request> queue,
+            Network network, DiskCache cache,
+            Delivery delivery) {
+        mQueue = queue;
+		mCache = cache;
+		mNetwork = network;
+        mDelivery = delivery;
+    }
+
+    /**
+     * Forces this dispatcher to quit immediately.  If any requests are still in
+     * the queue, they are not guaranteed to be processed.
+     */
+    public void quit() {
+        mQuit = true;
+        interrupt();
+    }
+
+    @Override
+    public void run() {
+        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
+        Request request;
+        while (true) {
+            try {
+                // Take a request from the queue.
+                request = mQueue.take();
+            } catch (InterruptedException e) {
+                // We may have been interrupted because it was time to quit.
+                if (mQuit) return;
+                continue;
+            }
+
+            try {
+                request.addMarker("network-queue-take");
+				mDelivery.postPreExecute(request);
+
+                // If the request was cancelled already,
+                // do not perform the network request.
+                if (request.isCanceled()) {
+                    request.finish("network-discard-cancelled");
+					mDelivery.postCancel(request);
+					mDelivery.postFinish(request);
+                    continue;
+                }
+
+                // Perform the network request.
+                NetworkResponse networkResponse = mNetwork.performRequest(request);
+                request.addMarker("network-http-complete");
+
+                // Parse the response here on the worker thread.
+                Response<?> response = request.parseNetworkResponse(networkResponse);
+                request.addMarker("network-parse-complete");
+
+                // Write to cache if applicable.
+				if (mCache != null && request.shouldCache() && response.cacheEntry != null) {
+					response.cacheEntry.expireTime = request.getCacheExpireTime();
+					mCache.putEntry(request.getCacheKey(), response.cacheEntry);
+					request.addMarker("network-cache-written");
+				}
+
+                // Post the response back.
+                request.markDelivered();
+                mDelivery.postResponse(request, response);
+            } catch (NetroidError netroidError) {
+				mDelivery.postError(request, request.parseNetworkError(netroidError));
+            } catch (Exception e) {
+				NetroidLog.e(e, "Unhandled exception %s", e.toString());
+				mDelivery.postError(request, new NetroidError(e));
+			}
+        }
+    }
+
+}
Index: app/src/main/java/com/duowan/mobile/netroid/stack/HttpStack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/stack/HttpStack.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/stack/HttpStack.java	(revision )
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.stack;
+
+import com.duowan.mobile.netroid.AuthFailureError;
+import com.duowan.mobile.netroid.Request;
+import org.apache.http.HttpResponse;
+
+import java.io.IOException;
+
+/**
+ * An HTTP stack abstraction.
+ */
+public interface HttpStack {
+    /**
+     * Performs an HTTP request with the given parameters.
+     *
+     * <p>A GET request is sent if request.getPostBody() == null. A POST request is sent otherwise,
+     * and the Content-Type header is set to request.getPostBodyContentType().</p>
+     *
+     * @param request the request to perform
+     * @return the HTTP response
+     */
+    public HttpResponse performRequest(Request<?> request)
+			throws IOException, AuthFailureError;
+}
Index: app/src/main/java/com/duowan/mobile/example/netroid/netroid/SelfImageLoader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/example/netroid/netroid/SelfImageLoader.java	(revision )
+++ app/src/main/java/com/duowan/mobile/example/netroid/netroid/SelfImageLoader.java	(revision )
@@ -0,0 +1,110 @@
+package com.duowan.mobile.example.netroid.netroid;
+
+import android.content.res.AssetManager;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import com.duowan.mobile.netroid.NetworkResponse;
+import com.duowan.mobile.netroid.RequestQueue;
+import com.duowan.mobile.netroid.request.ImageRequest;
+import com.duowan.mobile.netroid.toolbox.ImageLoader;
+import org.apache.http.protocol.HTTP;
+
+import java.io.ByteArrayOutputStream;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.TimeUnit;
+
+public class SelfImageLoader extends ImageLoader {
+
+	public static final String RES_ASSETS = "assets://";
+	public static final String RES_SDCARD = "sdcard://";
+	public static final String RES_DRAWABLE = "drawable://";
+	public static final String RES_HTTP = "http://";
+
+	private AssetManager mAssetManager;
+	private Resources mResources;
+
+	public SelfImageLoader(RequestQueue queue, ImageCache cache, Resources resources, AssetManager assetManager) {
+		super(queue, cache);
+		mResources = resources;
+		mAssetManager = assetManager;
+	}
+
+	@Override
+	public ImageRequest buildRequest(String requestUrl, int maxWidth, int maxHeight) {
+		ImageRequest request;
+		if (requestUrl.startsWith(RES_ASSETS)) {
+			request = new ImageRequest(requestUrl.substring(RES_ASSETS.length()), maxWidth, maxHeight) {
+				@Override
+				public NetworkResponse perform() {
+					try {
+						return new NetworkResponse(toBytes(mAssetManager.open(getUrl())), HTTP.UTF_8);
+					} catch (IOException e) {
+						return new NetworkResponse(new byte[1], HTTP.UTF_8);
+					}
+				}
+			};
+		}
+		else if (requestUrl.startsWith(RES_SDCARD)) {
+			request = new ImageRequest(requestUrl.substring(RES_SDCARD.length()), maxWidth, maxHeight) {
+				@Override
+				public NetworkResponse perform() {
+					try {
+						return new NetworkResponse(toBytes(new FileInputStream(getUrl())), HTTP.UTF_8);
+					} catch (IOException e) {
+						return new NetworkResponse(new byte[1], HTTP.UTF_8);
+					}
+				}
+			};
+		}
+		else if (requestUrl.startsWith(RES_DRAWABLE)) {
+			request = new ImageRequest(requestUrl.substring(RES_DRAWABLE.length()), maxWidth, maxHeight) {
+				@Override
+				public NetworkResponse perform() {
+					try {
+						int resId = Integer.parseInt(getUrl());
+						Bitmap bitmap = BitmapFactory.decodeResource(mResources, resId);
+						return new NetworkResponse(bitmap2Bytes(bitmap), HTTP.UTF_8);
+					} catch (Exception e) {
+						return new NetworkResponse(new byte[1], HTTP.UTF_8);
+					}
+				}
+			};
+		}
+		else if (requestUrl.startsWith(RES_HTTP)) {
+			request = new ImageRequest(requestUrl, maxWidth, maxHeight);
+		}
+		else {
+			return null;
+		}
+
+		makeRequest(request);
+		return request;
+	}
+
+	public void makeRequest(ImageRequest request) {
+		request.setCacheExpireTime(TimeUnit.MINUTES, 10);
+	}
+
+	public static byte[] toBytes(InputStream is) throws IOException {
+		ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+
+		int nRead;
+		byte[] data = new byte[16384];
+		while ((nRead = is.read(data, 0, data.length)) != -1) {
+			buffer.write(data, 0, nRead);
+		}
+		buffer.flush();
+
+		return buffer.toByteArray();
+	}
+
+	public static byte[] bitmap2Bytes(Bitmap bm) {
+		ByteArrayOutputStream baos = new ByteArrayOutputStream();
+		bm.compress(Bitmap.CompressFormat.PNG, 100, baos);
+		return baos.toByteArray();
+	}
+
+}
Index: app/src/main/java/com/duowan/mobile/netroid/NetworkResponse.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/NetworkResponse.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/NetworkResponse.java	(revision )
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+import org.apache.http.HttpStatus;
+
+/**
+ * Data and headers returned from {@link Network#performRequest(Request)}.
+ */
+public class NetworkResponse {
+    /**
+     * Creates a new network response.
+     * @param statusCode the HTTP status code
+     * @param data Response body
+     * @param charset The response body charset, parse by http header
+     */
+    public NetworkResponse(int statusCode, byte[] data, String charset) {
+		this.statusCode = statusCode;
+		this.data = data;
+        this.charset = charset;
+	}
+
+//    public NetworkResponse(byte[] data) {
+//        this(HttpStatus.SC_OK, data, Collections.<String, String>emptyMap());
+//    }
+
+    public NetworkResponse(byte[] data, String charset) {
+        this(HttpStatus.SC_OK, data, charset);
+    }
+
+    /** The HTTP status code. */
+    public final int statusCode;
+
+    /** Raw data from this response. */
+    public final byte[] data;
+
+    /** Charset from this response. */
+    public final String charset;
+}
\ No newline at end of file
Index: app/src/main/res/menu/menu_main.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/menu/menu_main.xml	(revision )
+++ app/src/main/res/menu/menu_main.xml	(revision )
@@ -0,0 +1,24 @@
+<menu xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    tools:context="com.example.bl_uestc.sercurity_bysound.MainActivity">
+
+    <item
+        android:id="@+id/ab_search"
+        android:orderInCategory="80"
+        android:title=""
+        app:actionViewClass="android.support.v7.widget.SearchView"
+        app:showAsAction="ifRoom"/>
+    <item
+        android:id="@+id/action_share"
+        android:orderInCategory="90"
+        android:title=""
+        app:actionProviderClass="android.support.v7.widget.ShareActionProvider"
+        app:showAsAction="ifRoom"/>
+    <item
+        android:id="@+id/action_settings"
+        android:orderInCategory="100"
+        android:title=""
+        app:showAsAction="never"/>
+
+</menu>
Index: app/src/main/res/values/styles.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/styles.xml	(revision )
+++ app/src/main/res/values/styles.xml	(revision )
@@ -0,0 +1,20 @@
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <item name="colorAccent">@color/colorAccent</item>
+    </style>
+
+    <style name="AppTheme.NoActionBar">
+        <item name="windowActionBar">false</item>
+        <item name="windowNoTitle">true</item>
+    </style>
+
+    <style name="AppTheme.AppBarOverlay" parent="ThemeOverlay.AppCompat.Dark.ActionBar" />
+
+    <style name="AppTheme.PopupOverlay" parent="ThemeOverlay.AppCompat.Light" />
+
+</resources>
Index: app/src/main/java/com/duowan/mobile/netroid/TimeoutError.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/TimeoutError.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/TimeoutError.java	(revision )
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+/**
+ * Indicates that the connection or the socket timed out.
+ */
+@SuppressWarnings("serial")
+public class TimeoutError extends NetroidError { }
Index: gradlew.bat
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- gradlew.bat	(revision )
+++ gradlew.bat	(revision )
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/vcs.xml	(revision )
+++ .idea/vcs.xml	(revision )
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/RequestQueue.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/RequestQueue.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/RequestQueue.java	(revision )
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+import android.os.Handler;
+import android.os.Looper;
+import com.duowan.mobile.netroid.cache.DiskCache;
+
+import java.util.*;
+import java.util.concurrent.PriorityBlockingQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * A request dispatch queue with a thread pool of dispatchers.
+ *
+ * Calling {@link #add(Request)} will enqueue the given Request for dispatch,
+ * resolving from either cache or network on a worker thread, and then delivering
+ * a parsed response on the main thread.
+ */
+@SuppressWarnings("rawtypes")
+public class RequestQueue {
+    /** Number of network request dispatcher threads to start. */
+    public static final int DEFAULT_NETWORK_THREAD_POOL_SIZE = 4;
+
+    /** Used for generating monotonically-increasing sequence numbers for requests. */
+    private AtomicInteger mSequenceGenerator = new AtomicInteger();
+
+    /**
+     * Staging area for requests that already have a duplicate request in flight.
+     *
+     * <ul>
+     *     <li>containsKey(cacheKey) indicates that there is a request in flight for the given cache
+     *          key.</li>
+     *     <li>get(cacheKey) returns waiting requests for the given cache key. The in flight request
+     *          is <em>not</em> contained in that list. Is null if no requests are staged.</li>
+     * </ul>
+     */
+    private final Map<String, Queue<Request>> mWaitingRequests =
+            new HashMap<String, Queue<Request>>();
+
+    /**
+     * The set of all requests currently being processed by this RequestQueue. A Request
+     * will be in this set if it is waiting in any queue or currently being processed by
+     * any dispatcher.
+     */
+    private final Set<Request> mCurrentRequests = new HashSet<Request>();
+
+    /** The cache triage queue. */
+    private final PriorityBlockingQueue<Request> mCacheQueue =
+        new PriorityBlockingQueue<Request>();
+
+    /** The queue of requests that are actually going out to the network. */
+    private final PriorityBlockingQueue<Request> mNetworkQueue =
+        new PriorityBlockingQueue<Request>();
+
+	/** Disk cache for retrieving and storing responses. */
+	private final DiskCache mCache;
+
+    /** Network interface for performing requests. */
+    private final Network mNetwork;
+
+    /** Request delivery mechanism. */
+    private final Delivery mDelivery;
+
+    /** The network dispatchers. */
+    private NetworkDispatcher[] mDispatchers;
+
+    /** The cache dispatcher. */
+    private CacheDispatcher mCacheDispatcher;
+
+    /**
+     * Creates the worker pool. Processing will not begin until {@link #start()} is called.
+     *
+     * @param network A Network interface for performing HTTP requests
+     * @param threadPoolSize Number of network dispatcher threads to create
+     * @param delivery A Delivery interface for posting responses and errors
+     * @param cache A Cache to use for persisting responses to disk
+     */
+    public RequestQueue(Network network, int threadPoolSize, Delivery delivery, DiskCache cache) {
+		mCache = cache;
+		mNetwork = network;
+		mDelivery = delivery;
+		mNetwork.setDelivery(delivery);
+		mDispatchers = new NetworkDispatcher[threadPoolSize];
+    }
+
+    /**
+     * Creates the worker pool. Processing will not begin until {@link #start()} is called.
+     *
+     * @param network A Network interface for performing HTTP requests
+     * @param threadPoolSize Number of network dispatcher threads to create
+	 * @param cache A Cache to use for persisting responses to disk
+     */
+    public RequestQueue(Network network, int threadPoolSize, DiskCache cache) {
+        this(network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper())), cache);
+    }
+
+    /**
+     * Creates the worker pool. Processing will not begin until {@link #start()} is called.
+     *
+     * @param network A Network interface for performing HTTP requests
+     */
+    public RequestQueue(Network network) {
+        this(network, DEFAULT_NETWORK_THREAD_POOL_SIZE, null);
+    }
+
+    /**
+     * Starts the dispatchers in this queue.
+     */
+    public void start() {
+        stop();  // Make sure any currently running dispatchers are stopped.
+        // Create the cache dispatcher and start it.
+        mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);
+        mCacheDispatcher.start();
+
+        // Create network dispatchers (and corresponding threads) up to the pool size.
+        for (int i = 0; i < mDispatchers.length; i++) {
+            NetworkDispatcher networkDispatcher =
+					new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery);
+            mDispatchers[i] = networkDispatcher;
+            networkDispatcher.start();
+        }
+    }
+
+    /**
+     * Stops the cache and network dispatchers.
+     */
+    public void stop() {
+        if (mCacheDispatcher != null) {
+            mCacheDispatcher.quit();
+        }
+		for (NetworkDispatcher mDispatcher : mDispatchers) {
+			if (mDispatcher != null) mDispatcher.quit();
+		}
+    }
+
+    /**
+     * Gets a sequence number.
+     */
+    public int getSequenceNumber() {
+        return mSequenceGenerator.incrementAndGet();
+    }
+
+	/**
+	 * Gets the thread pool size.
+	 */
+	public int getThreadPoolSize() {
+		return mDispatchers.length;
+	}
+
+
+
+    /**
+     * A simple predicate or filter interface for Requests, for use by
+     * {@link RequestQueue#cancelAll(RequestFilter)}.
+     */
+    public interface RequestFilter {
+        public boolean apply(Request<?> request);
+    }
+
+    /**
+     * Cancels all requests in this queue for which the given filter applies.
+     * @param filter The filtering function to use
+     */
+    public void cancelAll(RequestFilter filter) {
+        synchronized (mCurrentRequests) {
+            for (Request<?> request : mCurrentRequests) {
+                if (filter.apply(request)) {
+                    request.cancel();
+                }
+            }
+        }
+    }
+
+    /**
+     * Cancels all requests in this queue with the given tag. Tag must be non-null
+     * and equality is by identity.
+     */
+    public void cancelAll(final Object tag) {
+        if (tag == null) {
+            throw new IllegalArgumentException("Cannot cancelAll with a null tag");
+        }
+        cancelAll(new RequestFilter() {
+            @Override
+            public boolean apply(Request<?> request) {
+                return request.getTag() == tag;
+            }
+        });
+    }
+
+    /**
+     * Adds a Request to the dispatch queue.
+     * @param request The request to service
+     * @return The passed-in request
+     */
+    public Request add(Request request) {
+        // Tag the request as belonging to this queue and add it to the set of current requests.
+        request.setRequestQueue(this);
+        synchronized (mCurrentRequests) {
+            mCurrentRequests.add(request);
+        }
+
+        // Process requests in the order they are added.
+        request.setSequence(getSequenceNumber());
+        request.addMarker("add-to-queue");
+
+        // If the request is uncacheable or forceUpdate, skip the cache queue and go straight to the network.
+        if (request.isForceUpdate() || !request.shouldCache()) {
+			mDelivery.postNetworking(request);
+			mNetworkQueue.add(request);
+			return request;
+        }
+
+        // Insert request into stage if there's already a request with the same cache key in flight.
+        synchronized (mWaitingRequests) {
+            String cacheKey = request.getCacheKey();
+            if (mWaitingRequests.containsKey(cacheKey)) {
+                // There is already a request in flight. Queue up.
+                Queue<Request> stagedRequests = mWaitingRequests.get(cacheKey);
+                if (stagedRequests == null) {
+                    stagedRequests = new LinkedList<Request>();
+                }
+                stagedRequests.add(request);
+                mWaitingRequests.put(cacheKey, stagedRequests);
+                if (NetroidLog.DEBUG) {
+                    NetroidLog.v("Request for cacheKey=%s is in flight, putting on hold.", cacheKey);
+                }
+            } else {
+                // Insert 'null' queue for this cacheKey, indicating there is now a request in
+                // flight.
+                mWaitingRequests.put(cacheKey, null);
+                mCacheQueue.add(request);
+            }
+            return request;
+        }
+    }
+
+    /**
+     * Called from {@link Request#finish(String)}, indicating that processing of the given request
+     * has finished.
+     *
+     * <p>Releases waiting requests for <code>request.getCacheKey()</code> if
+     *      <code>request.shouldCache()</code>.</p>
+     */
+    void finish(Request request) {
+        // Remove from the set of requests currently being processed.
+        synchronized (mCurrentRequests) {
+            mCurrentRequests.remove(request);
+        }
+
+        if (!request.isForceUpdate() && request.shouldCache()) {
+            synchronized (mWaitingRequests) {
+                String cacheKey = request.getCacheKey();
+                Queue<Request> waitingRequests = mWaitingRequests.remove(cacheKey);
+                if (waitingRequests != null) {
+                    if (NetroidLog.DEBUG) {
+                        NetroidLog.v("Releasing %d waiting requests for cacheKey=%s.",
+								waitingRequests.size(), cacheKey);
+                    }
+                    // Process all queued up requests. They won't be considered as in flight, but
+                    // that's not a problem as the cache has been primed by 'request'.
+                    mCacheQueue.addAll(waitingRequests);
+                }
+            }
+        }
+    }
+}
Index: app/src/main/java/com/duowan/mobile/netroid/toolbox/AndroidAuthenticator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/toolbox/AndroidAuthenticator.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/toolbox/AndroidAuthenticator.java	(revision )
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.toolbox;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AccountManagerFuture;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Bundle;
+import com.duowan.mobile.netroid.AuthFailureError;
+
+/**
+ * An Authenticator that uses {@link AccountManager} to get auth
+ * tokens of a specified type for a specified account.
+ */
+public class AndroidAuthenticator implements Authenticator {
+    private final Context mContext;
+    private final Account mAccount;
+    private final String mAuthTokenType;
+    private final boolean mNotifyAuthFailure;
+
+    /**
+     * Creates a new authenticator.
+     * @param context Context for accessing AccountManager
+     * @param account Account to authenticate as
+     * @param authTokenType Auth token type passed to AccountManager
+     */
+    public AndroidAuthenticator(Context context, Account account, String authTokenType) {
+        this(context, account, authTokenType, false);
+    }
+
+    /**
+     * Creates a new authenticator.
+     * @param context Context for accessing AccountManager
+     * @param account Account to authenticate as
+     * @param authTokenType Auth token type passed to AccountManager
+     * @param notifyAuthFailure Whether to raise a notification upon auth failure
+     */
+    public AndroidAuthenticator(Context context, Account account, String authTokenType,
+            boolean notifyAuthFailure) {
+        mContext = context;
+        mAccount = account;
+        mAuthTokenType = authTokenType;
+        mNotifyAuthFailure = notifyAuthFailure;
+    }
+
+    /**
+     * Returns the Account being used by this authenticator.
+     */
+    public Account getAccount() {
+        return mAccount;
+    }
+
+    @Override
+    public String getAuthToken() throws AuthFailureError {
+        final AccountManager accountManager = AccountManager.get(mContext);
+        AccountManagerFuture<Bundle> future = accountManager.getAuthToken(mAccount,
+                mAuthTokenType, mNotifyAuthFailure, null, null);
+        Bundle result;
+        try {
+            result = future.getResult();
+        } catch (Exception e) {
+            throw new AuthFailureError("Error while retrieving auth token", e);
+        }
+        String authToken = null;
+        if (future.isDone() && !future.isCancelled()) {
+            if (result.containsKey(AccountManager.KEY_INTENT)) {
+                Intent intent = result.getParcelable(AccountManager.KEY_INTENT);
+                throw new AuthFailureError(intent);
+            }
+            authToken = result.getString(AccountManager.KEY_AUTHTOKEN);
+        }
+        if (authToken == null) {
+            throw new AuthFailureError("Got null auth token for type: " + mAuthTokenType);
+        }
+
+        return authToken;
+    }
+
+    @Override
+    public void invalidateAuthToken(String authToken) {
+        AccountManager.get(mContext).invalidateAuthToken(mAccount.type, authToken);
+    }
+}
Index: app/src/main/java/com/duowan/mobile/netroid/toolbox/Authenticator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/toolbox/Authenticator.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/toolbox/Authenticator.java	(revision )
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.toolbox;
+
+import com.duowan.mobile.netroid.AuthFailureError;
+
+/**
+ * An interface for interacting with auth tokens.
+ */
+public interface Authenticator {
+    /**
+     * Synchronously retrieves an auth token.
+     *
+     * @throws AuthFailureError If authentication did not succeed
+     */
+    public String getAuthToken() throws AuthFailureError;
+
+    /**
+     * Invalidates the provided auth token.
+     */
+    public void invalidateAuthToken(String authToken);
+}
Index: app/src/main/java/com/duowan/mobile/netroid/Network.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/Network.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/Network.java	(revision )
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+/**
+ * An interface for performing requests.
+ */
+public interface Network {
+
+	/** Set the request delivery that use to post http networking callbacks. */
+	public void setDelivery(Delivery delivery);
+	
+    /**
+     * Performs the specified request.
+     * @param request Request to process
+     * @return A {@link NetworkResponse} with data and caching metadata; will never be null
+     * @throws NetroidError on errors
+     */
+    public NetworkResponse performRequest(Request<?> request) throws NetroidError;
+}
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/compiler.xml	(revision )
+++ .idea/compiler.xml	(revision )
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <resourceExtensions />
+    <wildcardResourcePatterns>
+      <entry name="!?*.java" />
+      <entry name="!?*.form" />
+      <entry name="!?*.class" />
+      <entry name="!?*.groovy" />
+      <entry name="!?*.scala" />
+      <entry name="!?*.flex" />
+      <entry name="!?*.kt" />
+      <entry name="!?*.clj" />
+      <entry name="!?*.aj" />
+    </wildcardResourcePatterns>
+    <annotationProcessing>
+      <profile default="true" name="Default" enabled="false">
+        <processorPath useClasspath="true" />
+      </profile>
+    </annotationProcessing>
+  </component>
+</project>
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/ExecutorDelivery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/ExecutorDelivery.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/ExecutorDelivery.java	(revision )
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+import android.os.Handler;
+
+import java.util.concurrent.Executor;
+
+/**
+ * Delivers responses and errors.
+ */
+public class ExecutorDelivery implements Delivery {
+    /** Used for posting responses, typically to the main thread. */
+    private final Executor mResponsePoster;
+
+    /**
+     * Creates a new response delivery interface.
+     * @param handler {@link Handler} to post responses on
+     */
+    public ExecutorDelivery(final Handler handler) {
+        // Make an Executor that just wraps the handler.
+        mResponsePoster = new Executor() {
+            @Override
+            public void execute(Runnable command) {
+                handler.post(command);
+            }
+        };
+    }
+
+    /**
+     * Creates a new response delivery interface, mockable version
+     * for testing.
+     * @param executor For running delivery tasks
+     */
+    public ExecutorDelivery(Executor executor) {
+        mResponsePoster = executor;
+    }
+
+	@Override
+	public void postFinish(final Request<?> request) {
+		request.addMarker("post-finish");
+		mResponsePoster.execute(new Runnable() {
+			@Override
+			public void run() {
+				request.deliverFinish();
+			}
+		});
+	}
+
+	@Override
+    public void postResponse(Request<?> request, Response<?> response) {
+        postResponse(request, response, null);
+    }
+
+    @Override
+    public void postResponse(Request<?> request, Response<?> response, Runnable runnable) {
+        request.markDelivered();
+        request.addMarker("post-response");
+        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable));
+    }
+
+    @Override
+    public void postError(Request<?> request, NetroidError error) {
+        request.addMarker("post-error");
+        Response<?> response = Response.error(error);
+        mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null));
+    }
+
+    @Override
+    public void postCancel(final Request<?> request) {
+        request.addMarker("post-cancel");
+        mResponsePoster.execute(new Runnable() {
+			@Override
+			public void run() {
+				request.deliverCancel();
+			}
+		});
+    }
+
+	@Override
+	public void postPreExecute(final Request<?> request) {
+		request.addMarker("post-preexecute");
+		mResponsePoster.execute(new Runnable() {
+			@Override
+			public void run() {
+				request.deliverPreExecute();
+			}
+		});
+	}
+
+	@Override
+	public void postUsedCache(final Request<?> request) {
+		request.addMarker("post-preexecute");
+		mResponsePoster.execute(new Runnable() {
+			@Override
+			public void run() {
+				request.deliverUsedCache();
+			}
+		});
+	}
+
+	@Override
+	public void postNetworking(final Request<?> request) {
+		request.addMarker("post-networking");
+		mResponsePoster.execute(new Runnable() {
+			@Override
+			public void run() {
+				request.deliverNetworking();
+			}
+		});
+	}
+
+	@Override
+	public void postRetry(final Request<?> request) {
+		request.addMarker("post-preexecute");
+		mResponsePoster.execute(new Runnable() {
+			@Override
+			public void run() {
+				request.deliverRetry();
+			}
+		});
+	}
+
+	@Override
+	public void postDownloadProgress(final Request<?> request, final long fileSize, final long downloadedSize) {
+		request.addMarker("post-downloadprogress");
+		mResponsePoster.execute(new Runnable() {
+			@Override
+			public void run() {
+				request.deliverDownloadProgress(fileSize, downloadedSize);
+			}
+		});
+	}
+
+	/**
+     * A Runnable used for delivering network responses to a listener on the
+     * main thread.
+     */
+    @SuppressWarnings("rawtypes")
+    private class ResponseDeliveryRunnable implements Runnable {
+        private final Request mRequest;
+        private final Response mResponse;
+        private final Runnable mRunnable;
+
+        public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) {
+            mRequest = request;
+            mResponse = response;
+            mRunnable = runnable;
+        }
+
+        @SuppressWarnings("unchecked")
+        @Override
+        public void run() {
+            // If this request has canceled, finish it and don't deliver.
+            if (mRequest.isCanceled()) {
+                mRequest.finish("canceled-at-delivery");
+				mRequest.deliverFinish();
+                return;
+            }
+
+            // Deliver a normal response or error, depending.
+            if (mResponse.isSuccess()) {
+                mRequest.deliverSuccess(mResponse.result);
+            } else {
+                mRequest.deliverError(mResponse.error);
+            }
+
+            // If this is an intermediate response, add a marker, otherwise we're done
+            // and the request can be finished.
+            if (mResponse.intermediate) {
+                mRequest.addMarker("intermediate-response");
+            } else {
+                mRequest.finish("done");
+            }
+
+            // If we have been provided a post-delivery runnable, run it.
+            if (mRunnable != null) {
+                mRunnable.run();
+            }
+
+			mRequest.deliverFinish();
+       }
+    }
+}
Index: .idea/.name
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/.name	(revision )
+++ .idea/.name	(revision )
@@ -0,0 +1,1 @@
+Sercurity_BySound
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/request/FileDownloadRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/request/FileDownloadRequest.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/request/FileDownloadRequest.java	(revision )
@@ -0,0 +1,181 @@
+package com.duowan.mobile.netroid.request;
+
+import android.text.TextUtils;
+import com.duowan.mobile.netroid.*;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.protocol.HTTP;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.RandomAccessFile;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
+
+/**
+ * Its purpose is provide a big file download impmenetation, suport continuous transmission
+ * on the breakpoint download if server-side enable 'Content-Range' Header.
+ * for example:
+ * 		execute a request and submit header like this : Range=bytes=1000- (1000 means the begin point of the file).
+ * 		response return a header like this Content-Range=bytes 1000-1895834/1895835, that's continuous transmission,
+ * 		also return Accept-Ranges=bytes tell us the server-side supported range transmission.
+ *
+ * This request will stay longer in the thread which dependent your download file size,
+ * that will fill up your thread poll as soon as possible if you launch many request,
+ * if all threads is busy, the high priority request such as {@link StringRequest}
+ * might waiting long time, so don't use it alone.
+ * we highly recommend you to use it with the {@link com.duowan.mobile.netroid.toolbox.FileDownloader},
+ * FileDownloader maintain a download task queue, let's set the maximum parallel request count, the rest will await.
+ *
+ * By the way, this request priority was {@link Priority#LOW}, higher request will jump ahead it.
+ */
+public class FileDownloadRequest extends Request<Void> {
+	private File mStoreFile;
+	private File mTemporaryFile;
+
+	public FileDownloadRequest(String storeFilePath, String url) {
+		super(url, null);
+		mStoreFile = new File(storeFilePath);
+		mTemporaryFile = new File(storeFilePath + ".tmp");
+
+		// Turn the retries frequency greater.
+		setRetryPolicy(new DefaultRetryPolicy(DefaultRetryPolicy.DEFAULT_TIMEOUT_MS, 200, DefaultRetryPolicy.DEFAULT_BACKOFF_MULT));
+	}
+
+	/** Init or reset the Range header, ensure the begin position always be the temporary file size. */
+	@Override
+	public void prepare() {
+		// Note: if the request header "Range" greater than the actual length that server-size have,
+		// the response header "Content-Range" will return "bytes */[actual length]", that's wrong.
+		addHeader("Range", "bytes=" + mTemporaryFile.length() + "-");
+
+//		Suppress the HttpStack accept gzip encoding, avoid the progress calculate wrong problem.
+//		addHeader("Accept-Encoding", "identity");
+	}
+
+	/** Ignore the response content, just rename the TemporaryFile to StoreFile. */
+	@Override
+	protected Response<Void> parseNetworkResponse(NetworkResponse response) {
+		if (!isCanceled()) {
+			if (mTemporaryFile.canRead() && mTemporaryFile.length() > 0) {
+				if (mTemporaryFile.renameTo(mStoreFile)) {
+					return Response.success(null, response);
+				} else {
+					return Response.error(new NetroidError("Can't rename the download temporary file!"));
+				}
+			} else {
+				return Response.error(new NetroidError("Download temporary file was invalid!"));
+			}
+		}
+		return Response.error(new NetroidError("Request was Canceled!"));
+	}
+
+	/**
+	 * In this method, we got the Content-Length, with the TemporaryFile length,
+	 * we can calculate the actually size of the whole file, if TemporaryFile not exists,
+	 * we'll take the store file length then compare to actually size, and if equals,
+	 * we consider this download was already done.
+	 * We used {@link RandomAccessFile} to continue download, when download success,
+	 * the TemporaryFile will be rename to StoreFile.
+	 */
+	@Override
+	public byte[] handleResponse(HttpResponse response, Delivery delivery) throws IOException, ServerError {
+		// Content-Length might be negative when use HttpURLConnection because it default header Accept-Encoding is gzip,
+		// we can force set the Accept-Encoding as identity in prepare() method to slove this problem but also disable gzip response.
+		HttpEntity entity = response.getEntity();
+		long fileSize = entity.getContentLength();
+		if (fileSize <= 0) {
+			NetroidLog.d("Response doesn't present Content-Length!");
+		}
+
+		long downloadedSize = mTemporaryFile.length();
+		boolean isSupportRange = HttpUtils.isSupportRange(response);
+		if (isSupportRange) {
+			fileSize += downloadedSize;
+
+			// Verify the Content-Range Header, to ensure temporary file is part of the whole file.
+			// Sometime, temporary file length add response content-length might greater than actual file length,
+			// in this situation, we consider the temporary file is invalid, then throw an exception.
+			String realRangeValue = HttpUtils.getHeader(response, "Content-Range");
+			// response Content-Range may be null when "Range=bytes=0-"
+			if (!TextUtils.isEmpty(realRangeValue)) {
+				String assumeRangeValue = "bytes " + downloadedSize + "-" + (fileSize - 1);
+				if (TextUtils.indexOf(realRangeValue, assumeRangeValue) == -1) {
+					throw new IllegalStateException(
+							"The Content-Range Header is invalid Assume[" + assumeRangeValue + "] vs Real[" + realRangeValue + "], " +
+									"please remove the temporary file [" + mTemporaryFile + "].");
+				}
+			}
+		}
+
+		// Compare the store file size(after download successes have) to server-side Content-Length.
+		// temporary file will rename to store file after download success, so we compare the
+		// Content-Length to ensure this request already download or not.
+		if (fileSize > 0 && mStoreFile.length() == fileSize) {
+			// Rename the store file to temporary file, mock the download success. ^_^
+			mStoreFile.renameTo(mTemporaryFile);
+
+			// Deliver download progress.
+			delivery.postDownloadProgress(this, fileSize, fileSize);
+
+			return null;
+		}
+
+		RandomAccessFile tmpFileRaf = new RandomAccessFile(mTemporaryFile, "rw");
+
+		// If server-side support range download, we seek to last point of the temporary file.
+		if (isSupportRange) {
+			tmpFileRaf.seek(downloadedSize);
+		} else {
+			// If not, truncate the temporary file then start download from beginning.
+			tmpFileRaf.setLength(0);
+			downloadedSize = 0;
+		}
+
+		try {
+			InputStream in = entity.getContent();
+			// Determine the response gzip encoding, support for HttpClientStack download.
+			if (HttpUtils.isGzipContent(response) && !(in instanceof GZIPInputStream)) {
+				in = new GZIPInputStream(in);
+			}
+			byte[] buffer = new byte[6 * 1024]; // 6K buffer
+			int offset;
+
+			while ((offset = in.read(buffer)) != -1) {
+				tmpFileRaf.write(buffer, 0, offset);
+
+				downloadedSize += offset;
+				delivery.postDownloadProgress(this, fileSize, downloadedSize);
+
+				if (isCanceled()) {
+					delivery.postCancel(this);
+					break;
+				}
+			}
+		} finally {
+			try {
+				// Close the InputStream and release the resources by "consuming the content".
+				if (entity != null) entity.consumeContent();
+			} catch (Exception e) {
+				// This can happen if there was an exception above that left the entity in
+				// an invalid state.
+				NetroidLog.v("Error occured when calling consumingContent");
+			}
+			tmpFileRaf.close();
+		}
+
+		return null;
+	}
+
+	@Override
+	public Priority getPriority() {
+		return Priority.LOW;
+	}
+
+	/** Never use cache in this case. */
+	@Override
+	public void setCacheExpireTime(TimeUnit timeUnit, int amount) {
+	}
+
+}
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/NetroidLog.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/NetroidLog.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/NetroidLog.java	(revision )
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+import android.os.SystemClock;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+/** Logging helper class. */
+public class NetroidLog {
+    public static String TAG = "Netroid";
+
+    public static boolean DEBUG = Log.isLoggable(TAG, Log.VERBOSE);
+
+    /**
+     * Customize the log tag for your application, so that other apps
+     * using Netroid don't mix their logs with yours.
+     * <br />
+     * Enable the log property for your tag before starting your app:
+     * <br />
+     * {@code adb shell setprop log.tag.&lt;tag&gt;}
+     */
+    public static void setTag(String tag) {
+        d("Changing log tag to %s", tag);
+        TAG = tag;
+
+        // Reinitialize the DEBUG "constant"
+        DEBUG = Log.isLoggable(TAG, Log.VERBOSE);
+    }
+
+    public static void v(String format, Object... args) {
+        if (DEBUG) {
+            Log.v(TAG, buildMessage(format, args));
+        }
+    }
+
+    public static void d(String format, Object... args) {
+        Log.d(TAG, buildMessage(format, args));
+    }
+
+    public static void e(String format, Object... args) {
+        Log.e(TAG, buildMessage(format, args));
+    }
+
+    public static void e(Throwable tr, String format, Object... args) {
+        Log.e(TAG, buildMessage(format, args), tr);
+    }
+
+    public static void wtf(String format, Object... args) {
+        Log.wtf(TAG, buildMessage(format, args));
+    }
+
+    public static void wtf(Throwable tr, String format, Object... args) {
+        Log.wtf(TAG, buildMessage(format, args), tr);
+    }
+
+    /**
+     * Formats the caller's provided message and prepends useful info like
+     * calling thread ID and method name.
+     */
+    private static String buildMessage(String format, Object... args) {
+        String msg = (args == null || args.length == 0) ? format : String.format(Locale.US, format, args);
+        StackTraceElement[] trace = new Throwable().fillInStackTrace().getStackTrace();
+
+        String caller = "<unknown>";
+        // Walk up the stack looking for the first caller outside of NetroidLog.
+        // It will be at least two frames up, so start there.
+        for (int i = 2; i < trace.length; i++) {
+            Class<?> clazz = trace[i].getClass();
+            if (!clazz.equals(NetroidLog.class)) {
+                String callingClass = trace[i].getClassName();
+                callingClass = callingClass.substring(callingClass.lastIndexOf('.') + 1);
+                callingClass = callingClass.substring(callingClass.lastIndexOf('$') + 1);
+
+                caller = callingClass + "." + trace[i].getMethodName();
+                break;
+            }
+        }
+        return String.format(Locale.US, "[%d] %s: %s",
+                Thread.currentThread().getId(), caller, msg);
+    }
+
+    /**
+     * A simple event log with records containing a name, thread ID, and timestamp.
+     */
+    static class MarkerLog {
+        public static final boolean ENABLED = NetroidLog.DEBUG;
+
+        /** Minimum duration from first marker to last in an marker log to warrant logging. */
+        private static final long MIN_DURATION_FOR_LOGGING_MS = 0;
+
+        private static class Marker {
+            public final String name;
+            public final long thread;
+            public final long time;
+
+            public Marker(String name, long thread, long time) {
+                this.name = name;
+                this.thread = thread;
+                this.time = time;
+            }
+        }
+
+        private final List<Marker> mMarkers = new ArrayList<Marker>();
+        private boolean mFinished = false;
+
+        /** Adds a marker to this log with the specified name. */
+        public synchronized void add(String name, long threadId) {
+            if (mFinished) {
+                throw new IllegalStateException("Marker added to finished log");
+            }
+
+            mMarkers.add(new Marker(name, threadId, SystemClock.elapsedRealtime()));
+        }
+
+        /**
+         * Closes the log, dumping it to logcat if the time difference between
+         * the first and last markers is greater than {@link #MIN_DURATION_FOR_LOGGING_MS}.
+         * @param header Header string to print above the marker log.
+         */
+        public synchronized void finish(String header) {
+            mFinished = true;
+
+            long duration = getTotalDuration();
+            if (duration <= MIN_DURATION_FOR_LOGGING_MS) {
+                return;
+            }
+
+            long prevTime = mMarkers.get(0).time;
+            d("(%-4d ms) %s", duration, header);
+            for (Marker marker : mMarkers) {
+                long thisTime = marker.time;
+                d("(+%-4d) [%2d] %s", (thisTime - prevTime), marker.thread, marker.name);
+                prevTime = thisTime;
+            }
+        }
+
+        @Override
+        protected void finalize() throws Throwable {
+            // Catch requests that have been collected (and hence end-of-lifed)
+            // but had no debugging output printed for them.
+            if (!mFinished) {
+                finish("Request on the loose");
+                e("Marker log finalized without finish() - uncaught exit point for request");
+            }
+        }
+
+        /** Returns the time difference between the first and last events in this log. */
+        private long getTotalDuration() {
+            if (mMarkers.size() == 0) {
+                return 0;
+            }
+
+            long first = mMarkers.get(0).time;
+            long last = mMarkers.get(mMarkers.size() - 1).time;
+            return last - first;
+        }
+    }
+}
Index: app/src/main/java/com/duowan/mobile/netroid/HttpUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/HttpUtils.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/HttpUtils.java	(revision )
@@ -0,0 +1,90 @@
+package com.duowan.mobile.netroid;
+
+import android.text.TextUtils;
+import com.duowan.mobile.netroid.toolbox.ByteArrayPool;
+import com.duowan.mobile.netroid.toolbox.PoolingByteArrayOutputStream;
+import org.apache.http.Header;
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.protocol.HTTP;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.zip.GZIPInputStream;
+
+public class HttpUtils {
+
+	/** Reads the contents of HttpEntity into a byte[]. */
+	public static byte[] responseToBytes(HttpResponse response) throws IOException, ServerError {
+		HttpEntity entity = response.getEntity();
+		PoolingByteArrayOutputStream bytes =
+				new PoolingByteArrayOutputStream(ByteArrayPool.get(), (int) entity.getContentLength());
+		byte[] buffer = null;
+		try {
+			InputStream in = entity.getContent();
+			if (isGzipContent(response) && !(in instanceof GZIPInputStream)) {
+				in = new GZIPInputStream(in);
+			}
+
+			if (in == null) {
+				throw new ServerError();
+			}
+
+			buffer = ByteArrayPool.get().getBuf(1024);
+			int count;
+			while ((count = in.read(buffer)) != -1) {
+				bytes.write(buffer, 0, count);
+			}
+			return bytes.toByteArray();
+		} finally {
+			try {
+				// Close the InputStream and release the resources by "consuming the content".
+				entity.consumeContent();
+			} catch (IOException e) {
+				// This can happen if there was an exception above that left the entity in
+				// an invalid state.
+				NetroidLog.v("Error occured when calling consumingContent");
+			}
+			ByteArrayPool.get().returnBuf(buffer);
+			bytes.close();
+		}
+	}
+
+	/** Returns the charset specified in the Content-Type of this header. */
+	public static String getCharset(HttpResponse response) {
+		Header header = response.getFirstHeader(HTTP.CONTENT_TYPE);
+		if (header != null) {
+			String contentType = header.getValue();
+			if (!TextUtils.isEmpty(contentType)) {
+				String[] params = contentType.split(";");
+				for (int i = 1; i < params.length; i++) {
+					String[] pair = params[i].trim().split("=");
+					if (pair.length == 2) {
+						if (pair[0].equals("charset")) {
+							return pair[1];
+						}
+					}
+				}
+			}
+		}
+		return null;
+	}
+
+	public static String getHeader(HttpResponse response, String key) {
+		Header header = response.getFirstHeader(key);
+		return header == null ? null : header.getValue();
+	}
+
+	public static boolean isSupportRange(HttpResponse response) {
+		if (TextUtils.equals(getHeader(response, "Accept-Ranges"), "bytes")) {
+			return true;
+		}
+		String value = getHeader(response, "Content-Range");
+		return value != null && value.startsWith("bytes");
+	}
+
+	public static boolean isGzipContent(HttpResponse response) {
+		return TextUtils.equals(getHeader(response, "Content-Encoding"), "gzip");
+	}
+
+}
Index: .idea/gradle.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/gradle.xml	(revision )
+++ .idea/gradle.xml	(revision )
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="GradleSettings">
+    <option name="linkedExternalProjectsSettings">
+      <GradleProjectSettings>
+        <option name="distributionType" value="LOCAL" />
+        <option name="externalProjectPath" value="$PROJECT_DIR$" />
+        <option name="gradleHome" value="D:\android studio\gradle\gradle-2.8" />
+        <option name="gradleJvm" value="1.8" />
+        <option name="modules">
+          <set>
+            <option value="$PROJECT_DIR$" />
+            <option value="$PROJECT_DIR$/app" />
+          </set>
+        </option>
+      </GradleProjectSettings>
+    </option>
+  </component>
+</project>
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/cache/BitmapImageCache.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/cache/BitmapImageCache.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/cache/BitmapImageCache.java	(revision )
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.cache;
+
+import android.graphics.Bitmap;
+import com.duowan.mobile.netroid.toolbox.ImageLoader;
+
+public class BitmapImageCache extends LruCache<String, Bitmap> implements ImageLoader.ImageCache {
+	public BitmapImageCache(int maxSize) {
+		super(maxSize);
+	}
+
+	@Override
+	protected int sizeOf(String key, Bitmap value) {
+		return value.getRowBytes() * value.getHeight();
+	}
+
+	@Override
+	public Bitmap getBitmap(String url) {
+		return get(url);
+	}
+
+	@Override
+	public void putBitmap(String url, Bitmap bitmap) {
+		put(url, bitmap);
+	}
+
+}
Index: app/src/main/java/com/duowan/mobile/netroid/toolbox/BasicNetwork.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/toolbox/BasicNetwork.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/toolbox/BasicNetwork.java	(revision )
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.toolbox;
+
+import android.os.SystemClock;
+import com.duowan.mobile.netroid.*;
+import com.duowan.mobile.netroid.stack.HttpStack;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.StatusLine;
+import org.apache.http.conn.ConnectTimeoutException;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.SocketTimeoutException;
+
+/**
+ * A network performing Netroid requests over an {@link HttpStack}.
+ */
+public class BasicNetwork implements Network {
+    protected static final boolean DEBUG = NetroidLog.DEBUG;
+
+    private static int SLOW_REQUEST_THRESHOLD_MS = 3000;
+
+    private static int DEFAULT_POOL_SIZE = 4096;
+
+	private final HttpStack mHttpStack;
+
+	/** The default charset only use when response doesn't offer the Content-Type header. */
+	private final String mDefaultCharset;
+
+	/** Request delivery mechanism. */
+	private Delivery mDelivery;
+
+    /**
+     * @param httpStack HTTP stack to be used
+	 * @param defaultCharset default charset if response does not provided.
+     */
+    public BasicNetwork(HttpStack httpStack, String defaultCharset) {
+        // If a pool isn't passed in, then build a small default pool that will give us a lot of
+        // benefit and not use too much memory.
+        this(httpStack, DEFAULT_POOL_SIZE, defaultCharset);
+    }
+
+    /**
+     * @param httpStack HTTP stack to be used
+     * @param bytePoolSize Size of buffer pool that improves GC performance in copy operations.
+	 * @param defaultCharset when Http Header doesn't offer the 'Content-Type:Charset', it will be use.
+     */
+    public BasicNetwork(HttpStack httpStack, int bytePoolSize, String defaultCharset) {
+		ByteArrayPool.init(bytePoolSize);
+		mDefaultCharset = defaultCharset;
+		mHttpStack = httpStack;
+    }
+
+	@Override
+	public void setDelivery(Delivery delivery) {
+		mDelivery = delivery;
+	}
+
+	@Override
+	public NetworkResponse performRequest(Request<?> request) throws NetroidError {
+		// Determine if request had non-http perform.
+		NetworkResponse networkResponse = request.perform();
+		if (networkResponse != null) return networkResponse;
+
+		long requestStart = SystemClock.elapsedRealtime();
+		while (true) {
+			// If the request was cancelled already,
+			// do not perform the network request.
+			if (request.isCanceled()) {
+				request.finish("perform-discard-cancelled");
+				mDelivery.postCancel(request);
+				throw new NetworkError(networkResponse);
+			}
+
+			HttpResponse httpResponse = null;
+			byte[] responseContents = null;
+			try {
+				// prepare to perform this request, normally is reset the request headers.
+				request.prepare();
+
+				httpResponse = mHttpStack.performRequest(request);
+
+				StatusLine statusLine = httpResponse.getStatusLine();
+				int statusCode = statusLine.getStatusCode();
+				if (statusCode < 200 || statusCode > 299) throw new IOException();
+
+				responseContents = request.handleResponse(httpResponse, mDelivery);
+
+				// if the request is slow, log it.
+				long requestLifetime = SystemClock.elapsedRealtime() - requestStart;
+				logSlowRequests(requestLifetime, request, responseContents, statusLine);
+
+				return new NetworkResponse(statusCode, responseContents, parseCharset(httpResponse));
+			} catch (SocketTimeoutException e) {
+				attemptRetryOnException("socket", request, new TimeoutError());
+			} catch (ConnectTimeoutException e) {
+				attemptRetryOnException("connection", request, new TimeoutError());
+			} catch (MalformedURLException e) {
+				throw new RuntimeException("Bad URL " + request.getUrl(), e);
+			} catch (IOException e) {
+				if (httpResponse == null) throw new NoConnectionError(e);
+
+				int statusCode = httpResponse.getStatusLine().getStatusCode();
+				NetroidLog.e("Unexpected response code %d for %s", statusCode, request.getUrl());
+				if (responseContents != null) {
+					networkResponse = new NetworkResponse(statusCode, responseContents, parseCharset(httpResponse));
+					if (statusCode == HttpStatus.SC_UNAUTHORIZED || statusCode == HttpStatus.SC_FORBIDDEN) {
+						attemptRetryOnException("auth", request, new AuthFailureError(networkResponse));
+					} else {
+						// TODO: Only throw ServerError for 5xx status codes.
+						throw new ServerError(networkResponse);
+					}
+				} else {
+					throw new NetworkError(networkResponse);
+				}
+			}
+		}
+	}
+
+    /**
+     * Logs requests that took over SLOW_REQUEST_THRESHOLD_MS to complete.
+     */
+    private void logSlowRequests(long requestLifetime, Request<?> request,
+            byte[] responseContents, StatusLine statusLine) {
+        if (DEBUG || requestLifetime > SLOW_REQUEST_THRESHOLD_MS) {
+            NetroidLog.d("HTTP response for request=<%s> [lifetime=%d], [size=%s], " +
+					"[rc=%d], [retryCount=%s]", request, requestLifetime,
+					responseContents != null ? responseContents.length : "null",
+					statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());
+        }
+    }
+
+    /**
+     * Attempts to prepare the request for a retry. If there are no more attempts remaining in the
+     * request's retry policy, a timeout exception is thrown.
+     * @param request The request to use.
+     */
+    private void attemptRetryOnException(String logPrefix, Request<?> request,
+            NetroidError exception) throws NetroidError {
+        RetryPolicy retryPolicy = request.getRetryPolicy();
+        int oldTimeout = request.getTimeoutMs();
+
+        try {
+            retryPolicy.retry(exception);
+        } catch (NetroidError e) {
+            request.addMarker(String.format("%s-timeout-giveup [timeout=%s]", logPrefix, oldTimeout));
+            throw e;
+        }
+
+		request.addMarker(String.format("%s-retry [timeout=%s]", logPrefix, oldTimeout));
+		mDelivery.postRetry(request);
+    }
+
+    protected void logError(String what, String url, long start) {
+        long now = SystemClock.elapsedRealtime();
+        NetroidLog.v("HTTP ERROR(%s) %d ms to fetch %s", what, (now - start), url);
+    }
+
+	/**
+	 * Returns the charset specified in the Content-Type of this header,
+	 * or the defaultCharset if none can be found.
+	 */
+	private String parseCharset(HttpResponse response) {
+		String charset = HttpUtils.getCharset(response);
+		return charset == null ? mDefaultCharset : charset;
+	}
+
+	public String getDefaultCharset() {
+		return mDefaultCharset;
+	}
+
+}
Index: app/src/main/res/layout/mytoolbar.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/mytoolbar.xml	(revision )
+++ app/src/main/res/layout/mytoolbar.xml	(revision )
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<android.support.v7.widget.Toolbar xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/toolbar"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    android:background="?attr/colorPrimary"
+    android:minHeight="?attr/actionBarSize"
+     >
+</android.support.v7.widget.Toolbar>  
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/toolbox/PoolingByteArrayOutputStream.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/toolbox/PoolingByteArrayOutputStream.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/toolbox/PoolingByteArrayOutputStream.java	(revision )
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.toolbox;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+
+/**
+ * A variation of {@link java.io.ByteArrayOutputStream} that uses a pool of byte[] buffers instead
+ * of always allocating them fresh, saving on heap churn.
+ */
+public class PoolingByteArrayOutputStream extends ByteArrayOutputStream {
+    /**
+     * If the {@link #PoolingByteArrayOutputStream(ByteArrayPool)} constructor is called, this is
+     * the default size to which the underlying byte array is initialized.
+     */
+    private static final int DEFAULT_SIZE = 256;
+
+    private final ByteArrayPool mPool;
+
+    /**
+     * Constructs a new PoolingByteArrayOutputStream with a default size. If more bytes are written
+     * to this instance, the underlying byte array will expand.
+     */
+    public PoolingByteArrayOutputStream(ByteArrayPool pool) {
+        this(pool, DEFAULT_SIZE);
+    }
+
+    /**
+     * Constructs a new {@code ByteArrayOutputStream} with a default size of {@code size} bytes. If
+     * more than {@code size} bytes are written to this instance, the underlying byte array will
+     * expand.
+     *
+     * @param size initial size for the underlying byte array. The value will be pinned to a default
+     *        minimum size.
+     */
+    public PoolingByteArrayOutputStream(ByteArrayPool pool, int size) {
+        mPool = pool;
+        buf = mPool.getBuf(Math.max(size, DEFAULT_SIZE));
+    }
+
+    @Override
+    public void close() throws IOException {
+        mPool.returnBuf(buf);
+        buf = null;
+        super.close();
+    }
+
+    @Override
+    public void finalize() {
+        mPool.returnBuf(buf);
+    }
+
+    /**
+     * Ensures there is enough space in the buffer for the given number of additional bytes.
+     */
+    private void expand(int i) {
+        /* Can the buffer handle @i more bytes, if not expand it */
+        if (count + i <= buf.length) {
+            return;
+        }
+        byte[] newbuf = mPool.getBuf((count + i) * 2);
+        System.arraycopy(buf, 0, newbuf, 0, count);
+        mPool.returnBuf(buf);
+        buf = newbuf;
+    }
+
+    @Override
+    public synchronized void write(byte[] buffer, int offset, int len) {
+        expand(len);
+        super.write(buffer, offset, len);
+    }
+
+    @Override
+    public synchronized void write(int oneByte) {
+        expand(1);
+        super.write(oneByte);
+    }
+}
Index: app/src/main/java/com/duowan/mobile/netroid/Delivery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/Delivery.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/Delivery.java	(revision )
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+public interface Delivery {
+
+	/** Posts request finished callback for the given request. */
+	void postFinish(Request<?> request);
+
+    /** Parses a response from the network or cache and delivers it. */
+    public void postResponse(Request<?> request, Response<?> response);
+
+    /**
+     * Parses a response from the network or cache and delivers it. The provided
+     * Runnable will be executed after delivery.
+     */
+    public void postResponse(Request<?> request, Response<?> response, Runnable runnable);
+
+    /** Posts an error for the given request. */
+    public void postError(Request<?> request, NetroidError error);
+
+	/** Posts a cancel callback for the given request. */
+	void postCancel(Request<?> request);
+
+	/** Posts starting execute callback for the given request. */
+	void postPreExecute(Request<?> request);
+
+	/** Posts cache used callback for the given request. */
+	void postUsedCache(Request<?> request);
+
+	/** Posts networking callback for the given request. */
+	void postNetworking(Request<?> request);
+
+	/** Posts request retry callback for the given request. */
+	void postRetry(Request<?> request);
+
+	/** Posts file download progress stat. */
+	void postDownloadProgress(Request<?> request, long fileSize, long downloadedSize);
+}
Index: app/src/main/java/com/duowan/mobile/example/netroid/mock/Book.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/example/netroid/mock/Book.java	(revision )
+++ app/src/main/java/com/duowan/mobile/example/netroid/mock/Book.java	(revision )
@@ -0,0 +1,25 @@
+package com.duowan.mobile.example.netroid.mock;
+
+public class Book {
+	private String imageUrl;
+	private String name;
+	private String author;
+
+	public Book(String imageUrl, String name, String author) {
+		this.imageUrl = imageUrl;
+		this.name = name;
+		this.author = author;
+	}
+
+	public String getImageUrl() {
+		return imageUrl;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public String getAuthor() {
+		return author;
+	}
+}
Index: app/src/test/java/com/example/bl_uestc/sercurity_bysound/ExampleUnitTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/test/java/com/example/bl_uestc/sercurity_bysound/ExampleUnitTest.java	(revision )
+++ app/src/test/java/com/example/bl_uestc/sercurity_bysound/ExampleUnitTest.java	(revision )
@@ -0,0 +1,15 @@
+package com.example.bl_uestc.sercurity_bysound;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * To work on unit tests, switch the Test Artifact in the Build Variants view.
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/stack/HurlStack.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/stack/HurlStack.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/stack/HurlStack.java	(revision )
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.stack;
+
+import android.text.TextUtils;
+import com.duowan.mobile.netroid.AuthFailureError;
+import com.duowan.mobile.netroid.Request;
+import com.duowan.mobile.netroid.Request.Method;
+import org.apache.http.*;
+import org.apache.http.entity.BasicHttpEntity;
+import org.apache.http.message.BasicHeader;
+import org.apache.http.message.BasicHttpResponse;
+import org.apache.http.message.BasicStatusLine;
+import org.apache.http.protocol.HTTP;
+
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLSocketFactory;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map.Entry;
+
+/**
+ * An {@link HttpStack} based on {@link HttpURLConnection}.
+ */
+public class HurlStack implements HttpStack {
+
+    private String mUserAgent;
+    private final SSLSocketFactory mSslSocketFactory;
+
+    /**
+     * @param sslSocketFactory SSL factory to use for HTTPS connections
+     */
+    public HurlStack(String userAgent, SSLSocketFactory sslSocketFactory) {
+        mSslSocketFactory = sslSocketFactory;
+		mUserAgent = userAgent;
+    }
+
+	public HurlStack(String userAgent) {
+		this(userAgent, null);
+	}
+
+    @Override
+    public HttpResponse performRequest(Request<?> request) throws IOException, AuthFailureError {
+		HashMap<String, String> map = new HashMap<String, String>();
+		if (!TextUtils.isEmpty(mUserAgent)) {
+			map.put(HTTP.USER_AGENT, mUserAgent);
+		}
+		map.putAll(request.getHeaders());
+
+		URL parsedUrl = new URL(request.getUrl());
+		HttpURLConnection connection = openConnection(parsedUrl, request);
+		for (String headerName : map.keySet()) {
+			connection.addRequestProperty(headerName, map.get(headerName));
+		}
+
+		setConnectionParametersForRequest(connection, request);
+
+		int responseCode = connection.getResponseCode();
+		if (responseCode == -1) {
+			// -1 is returned by getResponseCode() if the response code could not be retrieved.
+			// Signal to the caller that something was wrong with the connection.
+			throw new IOException("Could not retrieve response code from HttpUrlConnection.");
+		}
+
+		StatusLine responseStatus = new BasicStatusLine(new ProtocolVersion("HTTP", 1, 1),
+                connection.getResponseCode(), connection.getResponseMessage());
+        BasicHttpResponse response = new BasicHttpResponse(responseStatus);
+        response.setEntity(entityFromConnection(connection));
+
+        for (Entry<String, List<String>> header : connection.getHeaderFields().entrySet()) {
+            if (header.getKey() != null) {
+                Header h = new BasicHeader(header.getKey(), header.getValue().get(0));
+                response.addHeader(h);
+            }
+        }
+
+        return response;
+    }
+
+    /**
+     * Initializes an {@link HttpEntity} from the given {@link HttpURLConnection}.
+     * @return an HttpEntity populated with data from <code>connection</code>.
+     */
+    private static HttpEntity entityFromConnection(HttpURLConnection connection) {
+        BasicHttpEntity entity = new BasicHttpEntity();
+        InputStream inputStream;
+        try {
+            inputStream = connection.getInputStream();
+        } catch (IOException ioe) {
+            inputStream = connection.getErrorStream();
+        }
+        entity.setContent(inputStream);
+        entity.setContentLength(connection.getContentLength());
+        entity.setContentEncoding(connection.getContentEncoding());
+        entity.setContentType(connection.getContentType());
+        return entity;
+    }
+
+    /**
+     * Create an {@link HttpURLConnection} for the specified {@code url}.
+     */
+    private HttpURLConnection createConnection(URL url) throws IOException {
+        return (HttpURLConnection) url.openConnection();
+    }
+
+    /**
+     * Opens an {@link HttpURLConnection} with parameters.
+     * @return an open connection
+     */
+    private HttpURLConnection openConnection(URL url, Request<?> request) throws IOException {
+        HttpURLConnection connection = createConnection(url);
+
+        int timeoutMs = request.getTimeoutMs();
+        connection.setConnectTimeout(timeoutMs);
+        connection.setReadTimeout(timeoutMs);
+        connection.setUseCaches(false);
+        connection.setDoInput(true);
+
+        // use caller-provided custom SslSocketFactory, if any, for HTTPS
+        if ("https".equals(url.getProtocol()) && mSslSocketFactory != null) {
+            ((HttpsURLConnection)connection).setSSLSocketFactory(mSslSocketFactory);
+        }
+
+        return connection;
+    }
+
+	private static void setConnectionParametersForRequest(
+			HttpURLConnection connection, Request<?> request) throws IOException, AuthFailureError {
+        switch (request.getMethod()) {
+            case Method.GET:
+                // Not necessary to set the request method because connection defaults to GET but
+                // being explicit here.
+                connection.setRequestMethod("GET");
+                break;
+            case Method.DELETE:
+                connection.setRequestMethod("DELETE");
+                break;
+            case Method.POST:
+                connection.setRequestMethod("POST");
+                addBodyIfExists(connection, request);
+                break;
+            case Method.PUT:
+                connection.setRequestMethod("PUT");
+                addBodyIfExists(connection, request);
+                break;
+            case Method.HEAD:
+                connection.setRequestMethod("HEAD");
+                break;
+            case Method.OPTIONS:
+                connection.setRequestMethod("OPTIONS");
+                break;
+            case Method.TRACE:
+                connection.setRequestMethod("TRACE");
+                break;
+            case Method.PATCH:
+                addBodyIfExists(connection, request);
+                connection.setRequestMethod("PATCH");
+                break;
+            default:
+                throw new IllegalStateException("Unknown method type.");
+        }
+    }
+
+    private static void addBodyIfExists(
+			HttpURLConnection connection, Request<?> request) throws IOException, AuthFailureError {
+        byte[] body = request.getBody();
+        if (body != null) {
+            connection.setDoOutput(true);
+            connection.addRequestProperty(HTTP.CONTENT_TYPE, request.getBodyContentType());
+            DataOutputStream out = new DataOutputStream(connection.getOutputStream());
+            out.write(body);
+            out.close();
+        }
+    }
+}
Index: app/src/main/res/values-w820dp/dimens.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values-w820dp/dimens.xml	(revision )
+++ app/src/main/res/values-w820dp/dimens.xml	(revision )
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/modules.xml	(revision )
+++ .idea/modules.xml	(revision )
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/Sercurity_BySound.iml" filepath="$PROJECT_DIR$/Sercurity_BySound.iml" />
+      <module fileurl="file://$PROJECT_DIR$/app/app.iml" filepath="$PROJECT_DIR$/app/app.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/request/ImageRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/request/ImageRequest.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/request/ImageRequest.java	(revision )
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.request;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.BitmapFactory;
+import com.duowan.mobile.netroid.*;
+
+/**
+ * A canned request for getting an image at a given URL and calling
+ * back with a decoded Bitmap.
+ */
+public class ImageRequest extends Request<Bitmap> {
+    /** Socket timeout in milliseconds for image requests */
+    private static final int IMAGE_TIMEOUT_MS = 1000;
+
+    /** Default number of retries for image requests */
+    private static final int IMAGE_MAX_RETRIES = 2;
+
+    /** Default backoff multiplier for image requests */
+    private static final float IMAGE_BACKOFF_MULT = 2f;
+
+    private Config mDecodeConfig;
+    private int mMaxWidth;
+    private int mMaxHeight;
+
+    /** Decoding lock so that we don't decode more than one image at a time (to avoid OOM's) */
+    private static final Object sDecodeLock = new Object();
+
+    /**
+     * Creates a new image request, decoding to a maximum specified width and
+     * height. If both width and height are zero, the image will be decoded to
+     * its natural size. If one of the two is nonzero, that dimension will be
+     * clamped and the other one will be set to preserve the image's aspect
+     * ratio. If both width and height are nonzero, the image will be decoded to
+     * be fit in the rectangle of dimensions width x height while keeping its
+     * aspect ratio.
+     *
+     * @param url URL of the image
+     * @param listener Listener to receive the decoded bitmap or error message
+     * @param maxWidth Maximum width to decode this bitmap to, or zero for none
+     * @param maxHeight Maximum height to decode this bitmap to, or zero for
+     *            none
+     * @param decodeConfig Format to decode the bitmap to
+     */
+    public ImageRequest(String url, Listener<Bitmap> listener, int maxWidth, int maxHeight, Config decodeConfig) {
+        super(Method.GET, url, listener);
+        setRetryPolicy(new DefaultRetryPolicy(IMAGE_TIMEOUT_MS, IMAGE_MAX_RETRIES, IMAGE_BACKOFF_MULT));
+        mDecodeConfig = decodeConfig;
+        mMaxWidth = maxWidth;
+        mMaxHeight = maxHeight;
+    }
+
+	public ImageRequest(String url, int maxWidth, int maxHeight) {
+		this(url, null, maxWidth, maxHeight, Config.RGB_565);
+	}
+
+    @Override
+    public Priority getPriority() {
+        return Priority.LOW;
+    }
+
+    /**
+     * Scales one side of a rectangle to fit aspect ratio.
+     *
+     * @param maxPrimary Maximum size of the primary dimension (i.e. width for
+     *        max width), or zero to maintain aspect ratio with secondary
+     *        dimension
+     * @param maxSecondary Maximum size of the secondary dimension, or zero to
+     *        maintain aspect ratio with primary dimension
+     * @param actualPrimary Actual size of the primary dimension
+     * @param actualSecondary Actual size of the secondary dimension
+     */
+    private static int getResizedDimension(int maxPrimary, int maxSecondary, int actualPrimary,
+            int actualSecondary) {
+        // If no dominant value at all, just return the actual.
+        if (maxPrimary == 0 && maxSecondary == 0) {
+            return actualPrimary;
+        }
+
+        // If primary is unspecified, scale primary to match secondary's scaling ratio.
+        if (maxPrimary == 0) {
+            double ratio = (double) maxSecondary / (double) actualSecondary;
+            return (int) (actualPrimary * ratio);
+        }
+
+        if (maxSecondary == 0) {
+            return maxPrimary;
+        }
+
+        double ratio = (double) actualSecondary / (double) actualPrimary;
+        int resized = maxPrimary;
+        if (resized * ratio > maxSecondary) {
+            resized = (int) (maxSecondary / ratio);
+        }
+        return resized;
+    }
+
+    @Override
+    protected Response<Bitmap> parseNetworkResponse(NetworkResponse response) {
+        // Serialize all decode on a global lock to reduce concurrent heap usage.
+        synchronized (sDecodeLock) {
+            try {
+                return doParse(response);
+            } catch (OutOfMemoryError e) {
+                NetroidLog.e("Caught OOM for %d byte image, url=%s", response.data.length, getUrl());
+                return Response.error(new ParseError(e));
+            }
+        }
+    }
+
+    /**
+     * The real guts of parseNetworkResponse. Broken out for readability.
+     */
+    private Response<Bitmap> doParse(NetworkResponse response) {
+        byte[] data = response.data;
+        BitmapFactory.Options decodeOptions = new BitmapFactory.Options();
+        Bitmap bitmap;
+        if (mMaxWidth == 0 && mMaxHeight == 0) {
+            decodeOptions.inPreferredConfig = mDecodeConfig;
+            bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);
+        } else {
+            // If we have to resize this image, first get the natural bounds.
+            decodeOptions.inJustDecodeBounds = true;
+            BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);
+            int actualWidth = decodeOptions.outWidth;
+            int actualHeight = decodeOptions.outHeight;
+
+            // Then compute the dimensions we would ideally like to decode to.
+            int desiredWidth = getResizedDimension(mMaxWidth, mMaxHeight,
+                    actualWidth, actualHeight);
+            int desiredHeight = getResizedDimension(mMaxHeight, mMaxWidth,
+                    actualHeight, actualWidth);
+
+            // Decode to the nearest power of two scaling factor.
+            decodeOptions.inJustDecodeBounds = false;
+            // TODO(ficus): Do we need this or is it okay since API 8 doesn't support it?
+            // decodeOptions.inPreferQualityOverSpeed = PREFER_QUALITY_OVER_SPEED;
+            decodeOptions.inSampleSize =
+                findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);
+            Bitmap tempBitmap =
+                BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);
+
+            // If necessary, scale down to the maximal acceptable size.
+            if (tempBitmap != null && (tempBitmap.getWidth() > desiredWidth ||
+                    tempBitmap.getHeight() > desiredHeight)) {
+                bitmap = Bitmap.createScaledBitmap(tempBitmap,
+                        desiredWidth, desiredHeight, true);
+                tempBitmap.recycle();
+            } else {
+                bitmap = tempBitmap;
+            }
+        }
+
+        if (bitmap == null) {
+            return Response.error(new ParseError(response));
+        } else {
+            return Response.success(bitmap, response);
+        }
+    }
+
+    /**
+     * Returns the largest power-of-two divisor for use in downscaling a bitmap
+     * that will not result in the scaling past the desired dimensions.
+     *
+     * @param actualWidth Actual width of the bitmap
+     * @param actualHeight Actual height of the bitmap
+     * @param desiredWidth Desired width of the bitmap
+     * @param desiredHeight Desired height of the bitmap
+     */
+    // Visible for testing.
+    static int findBestSampleSize(
+            int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) {
+        double wr = (double) actualWidth / desiredWidth;
+        double hr = (double) actualHeight / desiredHeight;
+        double ratio = Math.min(wr, hr);
+        float n = 1.0f;
+        while ((n * 2) <= ratio) {
+            n *= 2;
+        }
+
+        return (int) n;
+	}
+
+	public void setDecodeConfig(Config decodeConfig) {
+		this.mDecodeConfig = decodeConfig;
+	}
+
+	public void setMaxWidth(int maxWidth) {
+		this.mMaxWidth = maxWidth;
+	}
+
+	public void setMaxHeight(int maxHeight) {
+		this.mMaxHeight = maxHeight;
+	}
+}
Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/build.gradle	(revision )
+++ app/build.gradle	(revision )
@@ -0,0 +1,28 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 22
+    buildToolsVersion "23.0.2"
+
+    defaultConfig {
+        applicationId "com.example.bl_uestc.sercurity_bysound"
+        minSdkVersion 14
+        targetSdkVersion 22
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile 'junit:junit:4.12'
+    compile 'com.android.support:appcompat-v7:22.2.1'
+    compile 'com.android.support:design:22.2.1'
+    compile 'com.android.support:palette-v7:22.2.1'
+}
Index: app/src/main/java/com/duowan/mobile/netroid/request/JsonObjectRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/request/JsonObjectRequest.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/request/JsonObjectRequest.java	(revision )
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.request;
+
+import com.duowan.mobile.netroid.Listener;
+import com.duowan.mobile.netroid.NetworkResponse;
+import com.duowan.mobile.netroid.ParseError;
+import com.duowan.mobile.netroid.Response;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * A request for retrieving a {@link JSONObject} response body at a given URL, allowing for an
+ * optional {@link JSONObject} to be passed in as part of the request body.
+ */
+public class JsonObjectRequest extends JsonRequest<JSONObject> {
+    /**
+     * Creates a new request.
+     * @param method the HTTP method to use
+     * @param url URL to fetch the JSON from
+     * @param jsonRequest A {@link JSONObject} to post with the request. Null is allowed and
+     *   indicates no parameters will be posted along with request.
+     * @param listener Listener to receive the JSON response or error message
+     */
+    public JsonObjectRequest(int method, String url, JSONObject jsonRequest, Listener<JSONObject> listener) {
+        super(method, url, (jsonRequest == null) ? null : jsonRequest.toString(), listener);
+    }
+
+    /**
+     * Constructor which defaults to <code>GET</code> if <code>jsonRequest</code> is
+     * <code>null</code>, <code>POST</code> otherwise.
+     *
+     * @see #JsonObjectRequest(int, String, JSONObject, Listener)
+     */
+    public JsonObjectRequest(String url, JSONObject jsonRequest, Listener<JSONObject> listener) {
+        this(jsonRequest == null ? Method.GET : Method.POST, url, jsonRequest, listener);
+    }
+
+    @Override
+    protected Response<JSONObject> parseNetworkResponse(NetworkResponse response) {
+        try {
+            String jsonString = new String(response.data, response.charset);
+            return Response.success(new JSONObject(jsonString), response);
+        } catch (UnsupportedEncodingException e) {
+            return Response.error(new ParseError(e));
+        } catch (JSONException je) {
+            return Response.error(new ParseError(je));
+        }
+    }
+}
Index: app/src/main/java/com/duowan/mobile/netroid/Response.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/Response.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/Response.java	(revision )
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+import com.duowan.mobile.netroid.cache.DiskCache;
+
+/**
+ * Encapsulates a parsed response for delivery.
+ * @param <T> Parsed type of this response
+ */
+public class Response<T> {
+
+    /** Returns a successful response containing the parsed result. */
+    public static <T> Response<T> success(T result, NetworkResponse response) {
+        return new Response<T>(result, new DiskCache.Entry(response.data, response.charset));
+    }
+
+    /**
+     * Returns a failed response containing the given error code and an optional
+     * localized message displayed to the user.
+     */
+    public static <T> Response<T> error(NetroidError error) {
+        return new Response<T>(error);
+    }
+
+    /** Parsed response, or null in the case of error. */
+    public final T result;
+
+    /** Cache metadata for this response, or null in the case of error. */
+    public final DiskCache.Entry cacheEntry;
+
+    /** Detailed error information if <code>errorCode != OK</code>. */
+    public final NetroidError error;
+
+    /** True if this response was a soft-expired one and a second one MAY be coming. */
+    public boolean intermediate = false;
+
+    /**
+     * Returns whether this response is considered successful.
+     */
+    public boolean isSuccess() {
+        return error == null;
+    }
+
+    private Response(T result, DiskCache.Entry cacheEntry) {
+        this.result = result;
+        this.cacheEntry = cacheEntry;
+        this.error = null;
+    }
+
+    private Response(NetroidError error) {
+        this.result = null;
+        this.cacheEntry = null;
+        this.error = error;
+    }
+}
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision )
+++ .idea/misc.xml	(revision )
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="EntryPointsManager">
+    <entry_points version="2.0" />
+  </component>
+  <component name="NullableNotNullManager">
+    <option name="myDefaultNullable" value="android.support.annotation.Nullable" />
+    <option name="myDefaultNotNull" value="android.support.annotation.NonNull" />
+    <option name="myNullables">
+      <value>
+        <list size="4">
+          <item index="0" class="java.lang.String" itemvalue="org.jetbrains.annotations.Nullable" />
+          <item index="1" class="java.lang.String" itemvalue="javax.annotation.Nullable" />
+          <item index="2" class="java.lang.String" itemvalue="edu.umd.cs.findbugs.annotations.Nullable" />
+          <item index="3" class="java.lang.String" itemvalue="android.support.annotation.Nullable" />
+        </list>
+      </value>
+    </option>
+    <option name="myNotNulls">
+      <value>
+        <list size="4">
+          <item index="0" class="java.lang.String" itemvalue="org.jetbrains.annotations.NotNull" />
+          <item index="1" class="java.lang.String" itemvalue="javax.annotation.Nonnull" />
+          <item index="2" class="java.lang.String" itemvalue="edu.umd.cs.findbugs.annotations.NonNull" />
+          <item index="3" class="java.lang.String" itemvalue="android.support.annotation.NonNull" />
+        </list>
+      </value>
+    </option>
+  </component>
+  <component name="ProjectLevelVcsManager" settingsEditedManually="false">
+    <OptionsSetting value="true" id="Add" />
+    <OptionsSetting value="true" id="Remove" />
+    <OptionsSetting value="true" id="Checkout" />
+    <OptionsSetting value="true" id="Update" />
+    <OptionsSetting value="true" id="Status" />
+    <OptionsSetting value="true" id="Edit" />
+    <ConfirmationsSetting value="0" id="Add" />
+    <ConfirmationsSetting value="0" id="Remove" />
+  </component>
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_7" default="true" assert-keyword="true" jdk-15="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
+    <output url="file://$PROJECT_DIR$/build/classes" />
+  </component>
+  <component name="ProjectType">
+    <option name="id" value="Android" />
+  </component>
+  <component name="masterDetails">
+    <states>
+      <state key="ProjectJDKs.UI">
+        <settings>
+          <last-edited>Android API 18 Platform</last-edited>
+          <splitter-proportions>
+            <option name="proportions">
+              <list>
+                <option value="0.2" />
+              </list>
+            </option>
+          </splitter-proportions>
+        </settings>
+      </state>
+    </states>
+  </component>
+</project>
\ No newline at end of file
Index: gradle/wrapper/gradle-wrapper.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>GBK
===================================================================
--- gradle/wrapper/gradle-wrapper.properties	(revision )
+++ gradle/wrapper/gradle-wrapper.properties	(revision )
@@ -0,0 +1,6 @@
+#Wed Oct 21 11:34:03 PDT 2015
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.8-all.zip
Index: app/src/main/java/com/duowan/mobile/netroid/toolbox/ByteArrayPool.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/toolbox/ByteArrayPool.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/toolbox/ByteArrayPool.java	(revision )
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.toolbox;
+
+import java.util.*;
+
+/**
+ * ByteArrayPool is a source and repository of <code>byte[]</code> objects. Its purpose is to
+ * supply those buffers to consumers who need to use them for a short period of time and then
+ * dispose of them. Simply creating and disposing such buffers in the conventional manner can
+ * considerable heap churn and garbage collection delays on Android, which lacks good management of
+ * short-lived heap objects. It may be advantageous to trade off some memory in the form of a
+ * permanently allocated pool of buffers in order to gain heap performance improvements; that is
+ * what this class does.
+ * <p>
+ * A good candidate user for this class is something like an I/O system that uses large temporary
+ * <code>byte[]</code> buffers to copy data around. In these use cases, often the consumer wants
+ * the buffer to be a certain minimum size to ensure good performance (e.g. when copying data chunks
+ * off of a stream), but doesn't mind if the buffer is larger than the minimum. Taking this into
+ * account and also to maximize the odds of being able to reuse a recycled buffer, this class is
+ * free to return buffers larger than the requested size. The caller needs to be able to gracefully
+ * deal with getting buffers any size over the minimum.
+ * <p>
+ * If there is not a suitably-sized buffer in its recycling pool when a buffer is requested, this
+ * class will allocate a new buffer and return it.
+ * <p>
+ * This class has no special ownership of buffers it creates; the caller is free to take a buffer
+ * it receives from this pool, use it permanently, and never return it to the pool; additionally,
+ * it is not harmful to return to this pool a buffer that was allocated elsewhere, provided there
+ * are no other lingering references to it.
+ * <p>
+ * This class ensures that the total size of the buffers in its recycling pool never exceeds a
+ * certain byte limit. When a buffer is returned that would cause the pool to exceed the limit,
+ * least-recently-used buffers are disposed.
+ */
+public class ByteArrayPool {
+    /** The buffer pool, arranged both by last use and by buffer size */
+    private List<byte[]> mBuffersByLastUse = new LinkedList<byte[]>();
+    private List<byte[]> mBuffersBySize = new ArrayList<byte[]>(64);
+
+    /** The total size of the buffers in the pool */
+    private int mCurrentSize = 0;
+
+    /**
+     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay
+     * under this limit.
+     */
+    private final int mSizeLimit;
+
+    /** Compares buffers by size */
+    protected static final Comparator<byte[]> BUF_COMPARATOR = new Comparator<byte[]>() {
+        @Override
+        public int compare(byte[] lhs, byte[] rhs) {
+            return lhs.length - rhs.length;
+        }
+    };
+
+    /**
+     * @param sizeLimit the maximum size of the pool, in bytes
+     */
+    private ByteArrayPool(int sizeLimit) {
+        mSizeLimit = sizeLimit;
+    }
+
+	/** Singleton for this class. */
+	private static ByteArrayPool mPool;
+
+	/** Get the singleton instance. */
+	public static ByteArrayPool get() {
+		return mPool;
+	}
+
+	/** Init and persisting the singleton instance. */
+	public static void init(int poolSize) {
+		mPool = new ByteArrayPool(poolSize);
+	}
+
+    /**
+     * Returns a buffer from the pool if one is available in the requested size, or allocates a new
+     * one if a pooled one is not available.
+     *
+     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be
+     *        larger.
+     * @return a byte[] buffer is always returned.
+     */
+    public synchronized byte[] getBuf(int len) {
+        for (int i = 0; i < mBuffersBySize.size(); i++) {
+            byte[] buf = mBuffersBySize.get(i);
+            if (buf.length >= len) {
+                mCurrentSize -= buf.length;
+                mBuffersBySize.remove(i);
+                mBuffersByLastUse.remove(buf);
+                return buf;
+            }
+        }
+        return new byte[len];
+    }
+
+    /**
+     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted
+     * size.
+     *
+     * @param buf the buffer to return to the pool.
+     */
+    public synchronized void returnBuf(byte[] buf) {
+        if (buf == null || buf.length > mSizeLimit) {
+            return;
+        }
+        mBuffersByLastUse.add(buf);
+        int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);
+        if (pos < 0) {
+            pos = -pos - 1;
+        }
+        mBuffersBySize.add(pos, buf);
+        mCurrentSize += buf.length;
+        trim();
+    }
+
+    /**
+     * Removes buffers from the pool until it is under its size limit.
+     */
+    private synchronized void trim() {
+        while (mCurrentSize > mSizeLimit) {
+            byte[] buf = mBuffersByLastUse.remove(0);
+            mBuffersBySize.remove(buf);
+            mCurrentSize -= buf.length;
+        }
+    }
+
+}
Index: app/src/main/java/com/duowan/mobile/netroid/cache/DiskCache.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/cache/DiskCache.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/cache/DiskCache.java	(revision )
@@ -0,0 +1,557 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.cache;
+
+import android.os.SystemClock;
+import com.duowan.mobile.netroid.NetroidLog;
+
+import java.io.*;
+import java.util.*;
+
+/**
+ * LruCache implementation that caches files directly onto the hard disk in the specified
+ * directory. The default disk usage size is 5MB, but is configurable.
+ */
+public class DiskCache {
+
+    /** Map of the Key, CacheHeader pairs */
+    private final Map<String, CacheHeader> mEntries =
+            new LinkedHashMap<String, CacheHeader>(16, .75f, true);
+
+    /** Total amount of space currently used by the cache in bytes. */
+    private long mTotalSize = 0;
+
+    /** The root directory to use for the cache. */
+    private final File mRootDirectory;
+
+    /** The maximum size of the cache in bytes. */
+    private final int mMaxCacheSizeInBytes;
+
+    /** Default maximum disk usage in bytes. */
+    private static final int DEFAULT_DISK_USAGE_BYTES = 5 * 1024 * 1024;
+
+    /** High water mark percentage for the cache */
+    private static final float HYSTERESIS_FACTOR = 0.9f;
+
+    /** Magic number for current version of cache file format. */
+    private static final int CACHE_MAGIC = 0x20120504;
+
+    /**
+     * Constructs an instance of the DiskCache at the specified directory.
+     * @param rootDirectory The root directory of the cache.
+     * @param maxCacheSizeInBytes The maximum size of the cache in bytes.
+     */
+    public DiskCache(File rootDirectory, int maxCacheSizeInBytes) {
+        mRootDirectory = rootDirectory;
+        mMaxCacheSizeInBytes = maxCacheSizeInBytes;
+    }
+
+    /**
+     * Constructs an instance of the DiskCache at the specified directory using
+     * the default maximum cache size of 5MB.
+     * @param rootDirectory The root directory of the cache.
+     */
+    public DiskCache(File rootDirectory) {
+        this(rootDirectory, DEFAULT_DISK_USAGE_BYTES);
+    }
+
+    /**
+     * Clears the cache. Deletes all cached files from disk.
+     */
+    public synchronized void clearCache() {
+        File[] files = mRootDirectory.listFiles();
+        if (files != null) {
+            for (File file : files) {
+                file.delete();
+            }
+        }
+        mEntries.clear();
+        mTotalSize = 0;
+        NetroidLog.d("Cache cleared.");
+    }
+
+    /**
+     * Returns the cache entry with the specified key if it exists, null otherwise.
+     */
+    public synchronized Entry getEntry(String key) {
+        CacheHeader entry = mEntries.get(key);
+        // if the entry does not exist, return.
+        if (entry == null) {
+            return null;
+        }
+
+        File file = getFileForKey(key);
+        CountingInputStream cis = null;
+        try {
+            cis = new CountingInputStream(new FileInputStream(file));
+            CacheHeader.readHeader(cis); // eat header
+            byte[] data = streamToBytes(cis, (int) (file.length() - cis.bytesRead));
+            return entry.toCacheEntry(data);
+        } catch (IOException e) {
+            NetroidLog.d("%s: %s", file.getAbsolutePath(), e.toString());
+            removeEntry(key);
+            return null;
+        } finally {
+            if (cis != null) {
+                try {
+                    cis.close();
+                } catch (IOException ioe) {
+                }
+            }
+        }
+    }
+
+    /**
+     * Initializes the DiskCache by scanning for all files currently in the
+     * specified root directory. Creates the root directory if necessary.
+     */
+    public synchronized void initialize() {
+        if (!mRootDirectory.exists()) {
+            if (!mRootDirectory.mkdirs()) {
+                NetroidLog.e("Unable to create cache dir %s", mRootDirectory.getAbsolutePath());
+            }
+            return;
+        }
+
+        File[] files = mRootDirectory.listFiles();
+        if (files == null) {
+            return;
+        }
+        for (File file : files) {
+            FileInputStream fis = null;
+            try {
+                fis = new FileInputStream(file);
+                CacheHeader entry = CacheHeader.readHeader(fis);
+				if (entry.isExpired()) {
+					file.delete();
+				} else {
+					entry.size = file.length();
+					putEntry(entry.key, entry);
+				}
+            } catch (IOException e) {
+                if (file != null) {
+                   file.delete();
+                }
+            } finally {
+                try {
+                    if (fis != null) {
+                        fis.close();
+                    }
+                } catch (IOException ignored) { }
+            }
+        }
+    }
+
+    /**
+     * Invalidates an entry in the cache.
+     * @param key Cache key
+     * @param expireTime The new expireTime
+     */
+    public synchronized void invalidate(String key, long expireTime) {
+        Entry entry = getEntry(key);
+        if (Entry.invalidate(entry, expireTime)) {
+            putEntry(key, entry);
+        }
+    }
+
+    /**
+     * Puts the entry with the specified key into the cache.
+     */
+    public synchronized void putEntry(String key, Entry entry) {
+        pruneIfNeeded(entry.data.length);
+        File file = getFileForKey(key);
+        try {
+            FileOutputStream fos = new FileOutputStream(file);
+            CacheHeader e = new CacheHeader(key, entry);
+            e.writeHeader(fos);
+            fos.write(entry.data);
+            fos.close();
+            putEntry(key, e);
+            return;
+        } catch (IOException e) {
+        }
+        boolean deleted = file.delete();
+        if (!deleted) {
+            NetroidLog.d("Could not clean up file %s", file.getAbsolutePath());
+        }
+    }
+
+    /**
+     * Removes the specified key from the cache if it exists.
+     */
+    public synchronized void removeEntry(String key) {
+        boolean deleted = getFileForKey(key).delete();
+
+		// Removes the entry identified by 'key' from the cache.
+		CacheHeader entry = mEntries.get(key);
+		if (entry != null) {
+			mTotalSize -= entry.size;
+			mEntries.remove(key);
+		}
+
+        if (!deleted) {
+            NetroidLog.d("Could not delete cache entry for key=%s, filename=%s",
+					key, getFilenameForKey(key));
+        }
+    }
+
+    /**
+     * Creates a pseudo-unique filename for the specified cache key.
+     * @param key The key to generate a file name for.
+     * @return A pseudo-unique filename.
+     */
+    private String getFilenameForKey(String key) {
+        int firstHalfLength = key.length() / 2;
+        String localFilename = String.valueOf(key.substring(0, firstHalfLength).hashCode());
+        localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());
+        return localFilename;
+    }
+
+    /**
+     * Returns a file object for the given cache key.
+     */
+    public File getFileForKey(String key) {
+        return new File(mRootDirectory, getFilenameForKey(key));
+    }
+
+    /**
+     * Prunes the cache to fit the amount of bytes specified.
+     * @param neededSpace The amount of bytes we are trying to fit into the cache.
+     */
+    private void pruneIfNeeded(int neededSpace) {
+        if ((mTotalSize + neededSpace) < mMaxCacheSizeInBytes) {
+            return;
+        }
+        if (NetroidLog.DEBUG) {
+            NetroidLog.v("Pruning old cache entries.");
+        }
+
+        long before = mTotalSize;
+        int prunedFiles = 0;
+        long startTime = SystemClock.elapsedRealtime();
+
+        Iterator<Map.Entry<String, CacheHeader>> iterator = mEntries.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<String, CacheHeader> entry = iterator.next();
+            CacheHeader e = entry.getValue();
+            boolean deleted = getFileForKey(e.key).delete();
+            if (deleted) {
+                mTotalSize -= e.size;
+            } else {
+               NetroidLog.d("Could not delete cache entry for key=%s, filename=%s",
+					   e.key, getFilenameForKey(e.key));
+            }
+            iterator.remove();
+            prunedFiles++;
+
+            if ((mTotalSize + neededSpace) < mMaxCacheSizeInBytes * HYSTERESIS_FACTOR) {
+                break;
+            }
+        }
+
+        if (NetroidLog.DEBUG) {
+            NetroidLog.v("pruned %d files, %d bytes, %d ms",
+					prunedFiles, (mTotalSize - before), SystemClock.elapsedRealtime() - startTime);
+        }
+    }
+
+    /**
+     * Puts the entry with the specified key into the cache.
+     * @param key The key to identify the entry by.
+     * @param entry The entry to cache.
+     */
+    private void putEntry(String key, CacheHeader entry) {
+        if (!mEntries.containsKey(key)) {
+            mTotalSize += entry.size;
+        } else {
+            CacheHeader oldEntry = mEntries.get(key);
+            mTotalSize += (entry.size - oldEntry.size);
+        }
+        mEntries.put(key, entry);
+    }
+
+    /**
+     * Reads the contents of an InputStream into a byte[].
+     * */
+    private static byte[] streamToBytes(InputStream in, int length) throws IOException {
+        byte[] bytes = new byte[length];
+        int count;
+        int pos = 0;
+        while (pos < length && ((count = in.read(bytes, pos, length - pos)) != -1)) {
+            pos += count;
+        }
+        if (pos != length) {
+            throw new IOException("Expected " + length + " bytes, read " + pos + " bytes");
+        }
+        return bytes;
+    }
+
+    /**
+     * Handles holding onto the cache headers for an entry.
+     */
+    // Visible for testing.
+    static class CacheHeader {
+        /** The size of the data identified by this CacheHeader. (This is not
+         * serialized to disk. */
+        public long size;
+
+        /** The key that identifies the cache entry. */
+        public String key;
+
+		/** Expire time for cache entry. */
+		public long expireTime;
+
+		/** Charset for cache entry. */
+		public String charset;
+
+        private CacheHeader() {}
+
+        /**
+         * Instantiates a new CacheHeader object
+         * @param key The key that identifies the cache entry
+         * @param entry The cache entry.
+         */
+        public CacheHeader(String key, Entry entry) {
+            this.key = key;
+			this.size = entry.data.length;
+			this.expireTime = entry.expireTime;
+			this.charset = entry.charset;
+		}
+
+        /**
+         * Reads the header off of an InputStream and returns a CacheHeader object.
+         * @param is The InputStream to read from.
+         * @throws IOException
+         */
+        public static CacheHeader readHeader(InputStream is) throws IOException {
+            CacheHeader entry = new CacheHeader();
+            int magic = readInt(is);
+            if (magic != CACHE_MAGIC) {
+                // don't bother deleting, it'll get pruned eventually
+                throw new IOException();
+            }
+            entry.key = readString(is);
+            entry.expireTime = readLong(is);
+            entry.charset = readString(is);
+            return entry;
+        }
+
+        /**
+         * Creates a cache entry for the specified data.
+         */
+        public Entry toCacheEntry(byte[] data) {
+            Entry e = new Entry();
+            e.data = data;
+			e.expireTime = expireTime;
+			e.charset = charset;
+			return e;
+        }
+
+		/** True if the entry is expired. */
+		public boolean isExpired() {
+			return expireTime < System.currentTimeMillis();
+		}
+
+
+        /**
+         * Writes the contents of this CacheHeader to the specified OutputStream.
+         */
+        public boolean writeHeader(OutputStream os) {
+            try {
+                writeInt(os, CACHE_MAGIC);
+                writeString(os, key);
+                writeLong(os, expireTime);
+                writeString(os, charset);
+                os.flush();
+                return true;
+            } catch (IOException e) {
+                NetroidLog.d("%s", e.toString());
+                return false;
+            }
+        }
+    }
+
+	/**
+	 * Data and metadata for an entry returned by the cache.
+	 */
+	public static class Entry {
+		public Entry() {}
+
+		public Entry(byte[] data, String charset) {
+			this.data = data;
+			this.charset = charset;
+		}
+
+		/** The data returned from cache. */
+		public byte[] data;
+
+		/** Expire time for cache entry. */
+		public long expireTime;
+
+		/** Charset for cache entry, retrieve by the http header. */
+		public String charset;
+
+		/** True if the entry is expired. */
+		public boolean isExpired() {
+			return expireTime < System.currentTimeMillis();
+		}
+
+		/** True if a refresh is needed from the original data source. */
+		public boolean refreshNeeded() {
+			// still unimplemented, might be use a constant like 'refreshTime'?
+			return this.expireTime < System.currentTimeMillis();
+		}
+
+		/** Get the cache data size in byte. */
+		public int getSize() {
+			return data != null ? data.length : 0;
+		}
+
+		/** Invalidate cache entry by the expireTime. */
+		public static boolean invalidate(Entry entry, long expireTime) {
+			if (entry != null) {
+				entry.expireTime = expireTime;
+				return true;
+			}
+			return false;
+		}
+
+	}
+
+    private static class CountingInputStream extends FilterInputStream {
+        private int bytesRead = 0;
+
+        private CountingInputStream(InputStream in) {
+            super(in);
+        }
+
+        @Override
+        public int read() throws IOException {
+            int result = super.read();
+            if (result != -1) {
+                bytesRead++;
+            }
+            return result;
+        }
+
+        @Override
+        public int read(byte[] buffer, int offset, int count) throws IOException {
+            int result = super.read(buffer, offset, count);
+            if (result != -1) {
+                bytesRead += result;
+            }
+            return result;
+        }
+    }
+
+    /*
+     * Homebrewed simple serialization system used for reading and writing cache
+     * headers on disk. Once upon a time, this used the standard Java
+     * Object{Input,Output}Stream, but the default implementation relies heavily
+     * on reflection (even for standard types) and generates a ton of garbage.
+     */
+
+    /**
+     * Simple wrapper around {@link InputStream#read()} that throws EOFException
+     * instead of returning -1.
+     */
+    private static int read(InputStream is) throws IOException {
+        int b = is.read();
+        if (b == -1) {
+            throw new EOFException();
+        }
+        return b;
+    }
+
+    static void writeInt(OutputStream os, int n) throws IOException {
+        os.write((n >> 0) & 0xff);
+        os.write((n >> 8) & 0xff);
+        os.write((n >> 16) & 0xff);
+        os.write((n >> 24) & 0xff);
+    }
+
+    static int readInt(InputStream is) throws IOException {
+        int n = 0;
+        n |= (read(is) << 0);
+        n |= (read(is) << 8);
+        n |= (read(is) << 16);
+        n |= (read(is) << 24);
+        return n;
+    }
+
+    static void writeLong(OutputStream os, long n) throws IOException {
+        os.write((byte)(n >>> 0));
+        os.write((byte)(n >>> 8));
+        os.write((byte)(n >>> 16));
+        os.write((byte)(n >>> 24));
+        os.write((byte)(n >>> 32));
+        os.write((byte)(n >>> 40));
+        os.write((byte)(n >>> 48));
+        os.write((byte)(n >>> 56));
+    }
+
+    static long readLong(InputStream is) throws IOException {
+        long n = 0;
+        n |= ((read(is) & 0xFFL) << 0);
+        n |= ((read(is) & 0xFFL) << 8);
+        n |= ((read(is) & 0xFFL) << 16);
+        n |= ((read(is) & 0xFFL) << 24);
+        n |= ((read(is) & 0xFFL) << 32);
+        n |= ((read(is) & 0xFFL) << 40);
+        n |= ((read(is) & 0xFFL) << 48);
+        n |= ((read(is) & 0xFFL) << 56);
+        return n;
+    }
+
+    static void writeString(OutputStream os, String s) throws IOException {
+        byte[] b = s.getBytes("UTF-8");
+        writeLong(os, b.length);
+        os.write(b, 0, b.length);
+    }
+
+    static String readString(InputStream is) throws IOException {
+        int n = (int) readLong(is);
+        byte[] b = streamToBytes(is, n);
+        return new String(b, "UTF-8");
+    }
+
+    static void writeStringStringMap(Map<String, String> map, OutputStream os) throws IOException {
+        if (map != null) {
+            writeInt(os, map.size());
+            for (Map.Entry<String, String> entry : map.entrySet()) {
+                writeString(os, entry.getKey());
+                writeString(os, entry.getValue());
+            }
+        } else {
+            writeInt(os, 0);
+        }
+    }
+
+    static Map<String, String> readStringStringMap(InputStream is) throws IOException {
+        int size = readInt(is);
+        Map<String, String> result = (size == 0)
+                ? Collections.<String, String>emptyMap()
+                : new HashMap<String, String>(size);
+        for (int i = 0; i < size; i++) {
+            String key = readString(is).intern();
+            String value = readString(is).intern();
+            result.put(key, value);
+        }
+        return result;
+    }
+
+}
Index: app/src/androidTest/java/com/example/bl_uestc/sercurity_bysound/ApplicationTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/androidTest/java/com/example/bl_uestc/sercurity_bysound/ApplicationTest.java	(revision )
+++ app/src/androidTest/java/com/example/bl_uestc/sercurity_bysound/ApplicationTest.java	(revision )
@@ -0,0 +1,13 @@
+package com.example.bl_uestc.sercurity_bysound;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+/**
+ * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ */
+public class ApplicationTest extends ApplicationTestCase<Application> {
+    public ApplicationTest() {
+        super(Application.class);
+    }
+}
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/AuthFailureError.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/AuthFailureError.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/AuthFailureError.java	(revision )
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+import android.content.Intent;
+
+/**
+ * Error indicating that there was an authentication failure when performing a Request.
+ */
+@SuppressWarnings("serial")
+public class AuthFailureError extends NetroidError {
+    /** An intent that can be used to resolve this exception. (Brings up the password dialog.) */
+    private Intent mResolutionIntent;
+
+    public AuthFailureError() { }
+
+    public AuthFailureError(Intent intent) {
+        mResolutionIntent = intent;
+    }
+
+    public AuthFailureError(NetworkResponse response) {
+        super(response);
+    }
+
+    public AuthFailureError(String message) {
+        super(message);
+    }
+
+    public AuthFailureError(String message, Exception reason) {
+        super(message, reason);
+    }
+
+    public Intent getResolutionIntent() {
+        return mResolutionIntent;
+    }
+
+    @Override
+    public String getMessage() {
+        if (mResolutionIntent != null) {
+            return "User needs to (re)enter credentials.";
+        }
+        return super.getMessage();
+    }
+}
Index: app/src/main/java/com/duowan/mobile/netroid/request/JsonRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/request/JsonRequest.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/request/JsonRequest.java	(revision )
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.request;
+
+import com.duowan.mobile.netroid.*;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * A request for retrieving a T type response body at a given URL that also
+ * optionally sends along a JSON body in the request specified.
+ *
+ * @param <T> JSON type of response expected
+ */
+public abstract class JsonRequest<T> extends Request<T> {
+    /** Charset for request. */
+    private static final String PROTOCOL_CHARSET = "utf-8";
+
+    /** Content type for request. */
+    private static final String PROTOCOL_CONTENT_TYPE =
+        String.format("application/json; charset=%s", PROTOCOL_CHARSET);
+
+    private final String mRequestBody;
+
+    public JsonRequest(int method, String url, String requestBody, Listener<T> listener) {
+        super(method, url, listener);
+        mRequestBody = requestBody;
+    }
+
+    @Override
+    abstract protected Response<T> parseNetworkResponse(NetworkResponse response);
+
+    @Override
+    public String getBodyContentType() {
+        return PROTOCOL_CONTENT_TYPE;
+    }
+
+    @Override
+    public byte[] getBody() {
+        try {
+            return mRequestBody == null ? null : mRequestBody.getBytes(PROTOCOL_CHARSET);
+        } catch (UnsupportedEncodingException uee) {
+            NetroidLog.wtf("Unsupported Encoding while trying to get the bytes of %s using %s",
+					mRequestBody, PROTOCOL_CHARSET);
+            return null;
+        }
+    }
+}
Index: app/src/main/res/values/dimens.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/dimens.xml	(revision )
+++ app/src/main/res/values/dimens.xml	(revision )
@@ -0,0 +1,6 @@
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+    <dimen name="fab_margin">16dp</dimen>
+</resources>
Index: app/src/main/java/com/duowan/mobile/netroid/request/StringRequest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/request/StringRequest.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/request/StringRequest.java	(revision )
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid.request;
+
+import com.duowan.mobile.netroid.Listener;
+import com.duowan.mobile.netroid.NetworkResponse;
+import com.duowan.mobile.netroid.Request;
+import com.duowan.mobile.netroid.Response;
+
+import java.io.UnsupportedEncodingException;
+
+/**
+ * A canned request for retrieving the response body at a given URL as a String.
+ */
+public class StringRequest extends Request<String> {
+    /**
+     * Creates a new request with the given method.
+     *
+     * @param method the request {@link Method} to use
+     * @param url URL to fetch the string at
+     * @param listener Listener to receive the String response or error message
+     */
+    public StringRequest(int method, String url, Listener<String> listener) {
+        super(method, url, listener);
+    }
+
+    /**
+     * Creates a new GET request.
+     *
+     * @param url URL to fetch the string at
+     * @param listener Listener to receive the String response
+     */
+    public StringRequest(String url, Listener<String> listener) {
+        this(Method.GET, url, listener);
+    }
+
+    @Override
+    protected Response<String> parseNetworkResponse(NetworkResponse response) {
+        String parsed;
+        try {
+            parsed = new String(response.data, response.charset);
+        } catch (UnsupportedEncodingException e) {
+            parsed = new String(response.data);
+        }
+        return Response.success(parsed, response);
+    }
+}
Index: app/src/main/java/com/duowan/mobile/netroid/Request.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/Request.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/Request.java	(revision )
@@ -0,0 +1,590 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+import android.os.Handler;
+import android.os.Looper;
+import android.os.SystemClock;
+import com.duowan.mobile.netroid.NetroidLog.MarkerLog;
+import org.apache.http.HttpResponse;
+
+import java.io.IOException;
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Base class for all network requests.
+` * @param <T> The type of parsed response this request expects.
+ */
+public abstract class Request<T> implements Comparable<Request<T>> {
+
+    /**
+     * Default encoding for POST or PUT parameters. See {@link #getParamsEncoding()}.
+     */
+    private static final String DEFAULT_PARAMS_ENCODING = "UTF-8";
+
+    /**
+     * Supported request methods.
+     */
+    public interface Method {
+        int GET = 0;
+        int POST = 1;
+        int PUT = 2;
+        int DELETE = 3;
+        int HEAD = 4;
+        int OPTIONS = 5;
+        int TRACE = 6;
+        int PATCH = 7;
+    }
+
+    /** An event log tracing the lifetime of this request; for debugging. */
+    private final MarkerLog mEventLog = MarkerLog.ENABLED ? new MarkerLog() : null;
+
+	/**
+	 * Request method of this request.  Currently supports GET, POST, PUT, DELETE, HEAD, OPTIONS,
+	 * TRACE, and PATCH.
+	 */
+    private final int mMethod;
+
+    /** URL of this request. */
+    private final String mUrl;
+
+	/** The additional headers. */
+	private HashMap<String, String> mHashHeaders;
+
+    /** Listener interface for response and error. */
+    private Listener<T> mListener;
+
+    /** Sequence number of this request, used to enforce FIFO ordering. */
+    private Integer mSequence;
+
+    /** The request queue this request is associated with. */
+    private RequestQueue mRequestQueue;
+
+	/** perform request directly, ignore which caches should be used. */
+	private boolean mForceUpdate;
+
+    /** Whether or not this request has been canceled. */
+    private boolean mCanceled = false;
+
+    /** Whether or not a response has been delivered for this request yet. */
+    private boolean mResponseDelivered = false;
+
+    /** A cheap variant of request tracing used to dump slow requests. */
+    private long mRequestBirthTime = 0;
+
+    /** Threshold at which we should log the request (even when debug logging is not enabled). */
+    private static final long SLOW_REQUEST_THRESHOLD_MS = 3000;
+
+    /** The retry policy for this request. */
+    private RetryPolicy mRetryPolicy;
+
+	/** What time the cache is expired, in milliSeconds. */
+	private long mCacheExpireTime;
+
+    /** An opaque token tagging this request; used for bulk cancellation. */
+    private Object mTag;
+
+    /**
+     * Creates a new request with the given method (one of the values from {@link Method}),
+     * URL, and error listener.  Note that the normal response listener is not provided here as
+     * delivery of responses is provided by subclasses, who have a better idea of how to deliver
+     * an already-parsed response.
+     */
+    public Request(int method, String url, Listener<T> listener) {
+		mUrl = url;
+		mMethod = method;
+        mListener = listener;
+        setRetryPolicy(new DefaultRetryPolicy());
+		mHashHeaders = new HashMap<String, String>();
+    }
+
+	/** Creates a new request with GET method */
+	public Request(String url, Listener<T> listener) {
+		this(Method.GET, url, listener);
+	}
+
+    /**
+     * Return the method for this request.
+	 * Can be one of the values in {@link Method}.
+     */
+    public int getMethod() {
+        return mMethod;
+    }
+
+	/** Set the response listener. */
+	public void setListener(Listener<T> listener) {
+		mListener = listener;
+	}
+
+    /**
+     * Set a tag on this request. Can be used to cancel all requests with this
+     * tag by {@link RequestQueue#cancelAll(Object)}.
+     */
+    public void setTag(Object tag) {
+        mTag = tag;
+    }
+
+    /**
+     * Returns this request's tag.
+     * @see Request#setTag(Object)
+     */
+    public Object getTag() {
+        return mTag;
+    }
+
+    /**
+     * Sets the retry policy for this request.
+     */
+    public void setRetryPolicy(RetryPolicy retryPolicy) {
+        mRetryPolicy = retryPolicy;
+    }
+
+    /**
+     * Adds an event to this request's event log; for debugging.
+     */
+    public void addMarker(String tag) {
+        if (MarkerLog.ENABLED) {
+            mEventLog.add(tag, Thread.currentThread().getId());
+        } else if (mRequestBirthTime == 0) {
+            mRequestBirthTime = SystemClock.elapsedRealtime();
+        }
+    }
+
+    /**
+     * Notifies the request queue that this request has finished (successfully or with error).
+     *
+     * <p>Also dumps all events from this request's event log; for debugging.</p>
+     */
+    public void finish(final String tag) {
+        if (mRequestQueue != null) {
+            mRequestQueue.finish(this);
+        }
+        if (MarkerLog.ENABLED) {
+            final long threadId = Thread.currentThread().getId();
+            if (Looper.myLooper() != Looper.getMainLooper()) {
+                // If we finish marking off of the main thread, we need to
+                // actually do it on the main thread to ensure correct ordering.
+                Handler mainThread = new Handler(Looper.getMainLooper());
+                mainThread.post(new Runnable() {
+                    @Override
+                    public void run() {
+                        mEventLog.add(tag, threadId);
+                        mEventLog.finish(this.toString());
+                    }
+                });
+                return;
+            }
+
+            mEventLog.add(tag, threadId);
+            mEventLog.finish(this.toString());
+        } else {
+            long requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime;
+            if (requestTime >= SLOW_REQUEST_THRESHOLD_MS) {
+                NetroidLog.d("%d ms: %s", requestTime, this.toString());
+            }
+        }
+    }
+
+    /**
+     * Associates this request with the given queue. The request queue will be notified when this
+     * request has finished.
+     */
+    public void setRequestQueue(RequestQueue requestQueue) {
+        mRequestQueue = requestQueue;
+    }
+
+    /**
+     * Sets the sequence number of this request.  Used by {@link RequestQueue}.
+     */
+    public final void setSequence(int sequence) {
+        mSequence = sequence;
+    }
+
+    /**
+     * Returns the sequence number of this request.
+     */
+    public final int getSequence() {
+        if (mSequence == null) {
+            throw new IllegalStateException("getSequence called before setSequence");
+        }
+        return mSequence;
+    }
+
+    /**
+     * Returns the URL of this request.
+     */
+    public String getUrl() {
+        return mUrl;
+    }
+
+	/**
+	 * Returns the cache key for this request.
+	 * By default, this is the URL.
+	 */
+	public String getCacheKey() {
+		return getUrl();
+	}
+
+	/** Ask if should force update. */
+	public boolean isForceUpdate() {
+		return mForceUpdate;
+	}
+
+	/** tell {@link Network} should force update or no. */
+	public void setForceUpdate(boolean forceUpdate) {
+		this.mForceUpdate = forceUpdate;
+	}
+
+	public long getCacheExpireTime() {
+		return mCacheExpireTime;
+	}
+
+	/**
+	 * Set how long the cache is expired, {@link com.duowan.mobile.netroid.cache.DiskCache}
+	 * will determine the cache entry is expired or not.
+	 * For example :
+	 * Request.setCacheExpireTime(TimeUnit.MINUTES, 1); // cache stays one minute
+	 * Request.setCacheExpireTime(TimeUnit.DAYS, 2); // cache stays two days
+	 * @param timeUnit what unit for the amount value
+	 * @param amount how much unit should calculate
+	 */
+	public void setCacheExpireTime(TimeUnit timeUnit, int amount) {
+		this.mCacheExpireTime = System.currentTimeMillis() + timeUnit.toMillis(amount);
+	}
+
+	/**
+     * Mark this request as canceled.  No callback will be delivered.
+     */
+    public void cancel() {
+        mCanceled = true;
+    }
+
+    /**
+     * Returns true if this request has been canceled.
+     */
+    public boolean isCanceled() {
+        return mCanceled;
+    }
+
+    /**
+     * Returns a list of extra HTTP headers to go along with this request. Can
+     * throw {@link AuthFailureError} as authentication may be required to
+     * provide these values.
+     * @throws AuthFailureError In the event of auth failure
+     */
+    public final Map<String, String> getHeaders() throws AuthFailureError {
+        return mHashHeaders;
+    }
+
+	/**
+	 * Put a Header to RequestHeaders.
+	 * @param field header key
+	 * @param value header value
+	 */
+	public final void addHeader(String field, String value) {
+		// We don't accept duplicate header.
+		removeHeader(field);
+		mHashHeaders.put(field, value);
+	}
+
+	/**
+	 * Remove a header from RequestHeaders
+	 * @param field header key
+	 */
+	public final void removeHeader(String field) {
+		mHashHeaders.remove(field);
+	}
+
+    /**
+     * Returns a Map of parameters to be used for a POST or PUT request.  Can throw
+     * {@link AuthFailureError} as authentication may be required to provide these values.
+     *
+     * <p>Note that you can directly override {@link #getBody()} for custom data.</p>
+     *
+     * @throws AuthFailureError in the event of auth failure
+     */
+	public Map<String, String> getParams() throws AuthFailureError {
+        return null;
+    }
+
+    /**
+     * Returns which encoding should be used when converting POST or PUT parameters returned by
+     * {@link #getParams()} into a raw POST or PUT body.
+     *
+     * <p>This controls both encodings:
+     * <ol>
+     *     <li>The string encoding used when converting parameter names and values into bytes prior
+     *         to URL encoding them.</li>
+     *     <li>The string encoding used when converting the URL encoded parameters into a raw
+     *         byte array.</li>
+     * </ol>
+     */
+	public String getParamsEncoding() {
+        return DEFAULT_PARAMS_ENCODING;
+    }
+
+    public String getBodyContentType() {
+        return "application/x-www-form-urlencoded; charset=" + getParamsEncoding();
+    }
+
+    /**
+     * Returns the raw POST or PUT body to be sent.
+     *
+     * @throws AuthFailureError in the event of auth failure
+     */
+    public byte[] getBody() throws AuthFailureError {
+        Map<String, String> params = getParams();
+        if (params != null && params.size() > 0) {
+            return encodeParameters(params, getParamsEncoding());
+        }
+        return null;
+    }
+
+    /**
+     * Converts <code>params</code> into an application/x-www-form-urlencoded encoded string.
+     */
+    public static byte[] encodeParameters(Map<String, String> params, String paramsEncoding) {
+        StringBuilder encodedParams = new StringBuilder();
+        try {
+            for (Map.Entry<String, String> entry : params.entrySet()) {
+                encodedParams.append(URLEncoder.encode(entry.getKey(), paramsEncoding));
+                encodedParams.append('=');
+                encodedParams.append(URLEncoder.encode(entry.getValue(), paramsEncoding));
+                encodedParams.append('&');
+            }
+            return encodedParams.toString().getBytes(paramsEncoding);
+        } catch (UnsupportedEncodingException uee) {
+            throw new RuntimeException("Encoding not supported: " + paramsEncoding, uee);
+        }
+    }
+
+	/**
+	 * Prepare to execute, invoke before {@link com.duowan.mobile.netroid.stack.HttpStack#performRequest}.
+	 * it's original purpose is reset some request parameters after timeout then retry, especially headers,
+	 * the situation is when you have some headers need to init or reset every perform, for example the "Range"
+	 * header for download a file, you obviously must retrieve the begin position of file and reset the "Range"
+	 * for every time you going to retry, so that's why we add this method.
+	 */
+	public void prepare() {
+	}
+
+	/**
+	 * Handle the response for various request, normally, a request was a short and low memory-usage request,
+	 * thus we can parse the response-content as byte[] in memory.
+	 * However the {@link com.duowan.mobile.netroid.request.FileDownloadRequest}
+	 * itself was a large memory-usage case, that's inadvisable for parse all
+	 * response content to memory, so it had self-implement mechanism.
+	 */
+	public byte[] handleResponse(HttpResponse response, Delivery delivery) throws IOException, ServerError {
+		// Some responses such as 204s do not have content.
+		if (response.getEntity() != null) {
+			return HttpUtils.responseToBytes(response);
+		} else {
+			// Add 0 byte response as a way of honestly representing a no-content request.
+			return new byte[0];
+		}
+	}
+
+	/**
+	 * By default, everyone Request is http-base request, if you wants to load
+	 * local file or perform others, also wants to use Cache, you can override
+	 * this method to implement non-http request.
+	 */
+	public NetworkResponse perform() {
+		return null;
+	}
+
+	/**
+     * Returns true if responses to this request should be cached.
+     */
+    public final boolean shouldCache() {
+		return mCacheExpireTime > 0;
+	}
+
+	/**
+     * Priority values.  Requests will be processed from higher priorities to
+     * lower priorities, in FIFO order.
+     */
+    public enum Priority {
+        LOW,
+        NORMAL,
+        HIGH,
+        IMMEDIATE
+    }
+
+    /**
+     * Returns the {@link Priority} of this request; {@link Priority#NORMAL} by default.
+     */
+    public Priority getPriority() {
+        return Priority.NORMAL;
+    }
+
+    /**
+     * Returns the socket timeout in milliseconds per retry attempt. (This value can be changed
+     * per retry attempt if a backoff is specified via backoffTimeout()). If there are no retry
+     * attempts remaining, this will cause delivery of a {@link TimeoutError} error.
+     */
+    public final int getTimeoutMs() {
+        return mRetryPolicy.getCurrentTimeout();
+    }
+
+    /**
+     * Returns the retry policy that should be used  for this request.
+     */
+    public RetryPolicy getRetryPolicy() {
+        return mRetryPolicy;
+    }
+
+    /**
+     * Mark this request as having a response delivered on it. This can be used
+     * later in the request's lifetime for suppressing identical responses.
+     */
+    public void markDelivered() {
+        mResponseDelivered = true;
+    }
+
+    /**
+     * Returns true if this request has had a response delivered for it.
+     */
+    public boolean hasHadResponseDelivered() {
+        return mResponseDelivered;
+    }
+
+    /**
+     * Subclasses must implement this to parse the raw network response
+     * and return an appropriate response type. This method will be
+     * called from a worker thread.  The response will not be delivered
+     * if you return null.
+     * @param response Response from the network
+     * @return The parsed response, or null in the case of an error
+     */
+    protected abstract Response<T> parseNetworkResponse(NetworkResponse response);
+
+    /**
+     * Subclasses can override this method to parse 'networkError' and return a more specific error.
+     *
+     * <p>The default implementation just returns the passed 'networkError'.</p>
+     *
+     * @param netroidError the error retrieved from the network
+     * @return an NetworkError augmented with additional information
+     */
+    protected NetroidError parseNetworkError(NetroidError netroidError) {
+        return netroidError;
+    }
+
+    /**
+     * Perform delivery of the parsed response. The given response is guaranteed to
+     * be non-null; responses that fail to parse are not delivered.
+     * @param response The parsed response returned by
+     * {@link #parseNetworkResponse(NetworkResponse)}
+     */
+    public void deliverSuccess(T response) {
+		if (mListener != null) {
+			mListener.onSuccess(response);
+		}
+	}
+
+    /**
+     * Delivers error message to the Listener that the Request was initialized with.
+     * @param error Error details
+     */
+    public void deliverError(NetroidError error) {
+        if (mListener != null) {
+            mListener.onError(error);
+        }
+    }
+
+	/** Delivers request has truly cancelled to the Listener. */
+	public void deliverCancel() {
+		if (mListener != null) {
+			mListener.onCancel();
+		}
+	}
+
+	/** Indicates DeliverPreExecute operation is done or not,
+	 * because the {@link CacheDispatcher} and {@link NetworkDispatcher}
+	 * both will call this deliver, and we must ensure just invoke once. */
+	private boolean mIsDeliverPreExecute;
+
+	/** Delivers request is handling to the Listener. */
+	public void deliverPreExecute() {
+		if (mListener != null && !mIsDeliverPreExecute) {
+			mIsDeliverPreExecute = true;
+			mListener.onPreExecute();
+		}
+	}
+
+	/** Delivers when cache used to the Listener. */
+	public void deliverUsedCache() {
+		if (mListener != null) {
+			mListener.onUsedCache();
+		}
+	}
+
+	/** Delivers when cache used to the Listener. */
+	public void deliverFinish() {
+		if (mListener != null) {
+			mListener.onFinish();
+		}
+	}
+
+	/** Delivers when request timeout and retry to the Listener. */
+	public void deliverRetry() {
+		if (mListener != null) {
+			mListener.onRetry();
+		}
+	}
+
+	/** Delivers when request going to do networking to the Listener. */
+	public void deliverNetworking() {
+		if (mListener != null) {
+			mListener.onNetworking();
+		}
+	}
+
+	/** Delivers when download request progress change to the Listener. */
+	public void deliverDownloadProgress(long fileSize, long downloadedSize) {
+		if (mListener != null) {
+			mListener.onProgressChange(fileSize, downloadedSize);
+		}
+	}
+
+    /**
+     * Our comparator sorts from high to low priority, and secondarily by
+     * sequence number to provide FIFO ordering.
+     */
+    @Override
+    public int compareTo(Request<T> other) {
+        Priority left = this.getPriority();
+        Priority right = other.getPriority();
+
+        // High-priority requests are "lesser" so they are sorted to the front.
+        // Equal priorities are sorted by sequence number to provide FIFO ordering.
+        return left == right ?
+                this.mSequence - other.mSequence :
+                right.ordinal() - left.ordinal();
+    }
+
+    @Override
+    public String toString() {
+        return (mCanceled ? "[X] " : "[ ] ") + getUrl() + " " + getPriority() + " " + mSequence;
+    }
+}
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- build.gradle	(revision )
+++ build.gradle	(revision )
@@ -0,0 +1,23 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+
+buildscript {
+    repositories {
+        jcenter()
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.5.0'
+
+        // NOTE: Do not place your application dependencies here; they belong
+        // in the individual module build.gradle files
+    }
+}
+
+allprojects {
+    repositories {
+        jcenter()
+    }
+}
+
+task clean(type: Delete) {
+    delete rootProject.buildDir
+}
Index: .idea/copyright/profiles_settings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/copyright/profiles_settings.xml	(revision )
+++ .idea/copyright/profiles_settings.xml	(revision )
@@ -0,0 +1,3 @@
+<component name="CopyrightManager">
+  <settings default="" />
+</component>
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/ParseError.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/ParseError.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/ParseError.java	(revision )
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+/**
+ * Indicates that the server's response could not be parsed.
+ */
+@SuppressWarnings("serial")
+public class ParseError extends NetroidError {
+    public ParseError() { }
+
+    public ParseError(NetworkResponse networkResponse) {
+        super(networkResponse);
+    }
+
+    public ParseError(Throwable cause) {
+        super(cause);
+    }
+}
Index: .idea/runConfigurations.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/runConfigurations.xml	(revision )
+++ .idea/runConfigurations.xml	(revision )
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="RunConfigurationProducerService">
+    <option name="ignoredProducers">
+      <set>
+        <option value="org.jetbrains.plugins.gradle.execution.test.runner.AllInPackageGradleConfigurationProducer" />
+        <option value="org.jetbrains.plugins.gradle.execution.test.runner.TestClassGradleConfigurationProducer" />
+        <option value="org.jetbrains.plugins.gradle.execution.test.runner.TestMethodGradleConfigurationProducer" />
+      </set>
+    </option>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/encodings.xml	(revision )
+++ .idea/encodings.xml	(revision )
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding">
+    <file url="PROJECT" charset="UTF-8" />
+  </component>
+</project>
\ No newline at end of file
Index: app/src/main/java/com/duowan/mobile/netroid/NetroidError.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/duowan/mobile/netroid/NetroidError.java	(revision )
+++ app/src/main/java/com/duowan/mobile/netroid/NetroidError.java	(revision )
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.duowan.mobile.netroid;
+
+/**
+ * Exception style class encapsulating Netroid errors
+ */
+@SuppressWarnings("serial")
+public class NetroidError extends Exception {
+    public final NetworkResponse networkResponse;
+
+    public NetroidError() {
+        networkResponse = null;
+    }
+
+    public NetroidError(NetworkResponse response) {
+        networkResponse = response;
+    }
+
+    public NetroidError(String exceptionMessage) {
+       super(exceptionMessage);
+       networkResponse = null;
+    }
+
+    public NetroidError(String exceptionMessage, Throwable reason) {
+        super(exceptionMessage, reason);
+        networkResponse = null;
+    }
+
+    public NetroidError(Throwable cause) {
+        super(cause);
+        networkResponse = null;
+    }
+}
Index: app/src/main/res/layout/main.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/layout/main.xml	(revision )
+++ app/src/main/res/layout/main.xml	(revision )
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    >
+
+    <android.support.v4.widget.DrawerLayout
+        android:id="@+id/id_drawerlayout"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+
+            <LinearLayout
+                android:id="@+id/ll_content"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:orientation="vertical"
+                android:background="@drawable/back_25"
+                >
+                <TextView
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:text="New Text"
+                    android:id="@+id/textView" />
+            </LinearLayout>
+
+
+        <!---->
+        <LinearLayout
+            android:id="@+id/ll_tabs"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:background="@android:color/darker_gray"
+            android:orientation="vertical"
+            android:layout_gravity="start">
+
+            <TextView
+                android:id="@+id/tv_close"
+                android:layout_width="match_parent"
+                android:layout_height="match_parent"
+                android:gravity="center"
+                android:clickable="true"
+                android:text=","
+                android:textColor="@android:color/white"/>
+
+
+
+        </LinearLayout>
+
+
+
+
+
+        </android.support.v4.widget.DrawerLayout>
+
+
+</LinearLayout>
